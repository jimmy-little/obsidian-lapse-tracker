/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LapsePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  dateFormat: "YYYY-MM-DD HH:mm:ss",
  showSeconds: true,
  startTimeKey: "startTime",
  endTimeKey: "endTime",
  entriesKey: "lapseEntries",
  totalTimeKey: "totalTimeTracked",
  projectKey: "project",
  defaultLabelType: "freeText",
  defaultLabelText: "",
  defaultLabelFrontmatterKey: "project",
  timeAdjustMinutes: 5
};
var LapsePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.timeData = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    console.log("Loading Lapse plugin");
    this.registerMarkdownCodeBlockProcessor("lapse", this.processTimerCodeBlock.bind(this));
    this.registerView(
      "lapse-sidebar",
      (leaf) => new LapseSidebarView(leaf, this)
    );
    this.addRibbonIcon("clock", "Lapse: Show Active Timers", () => {
      this.activateView();
    });
    this.addCommand({
      id: "insert-lapse-timer",
      name: "Insert time tracker",
      editorCallback: (editor) => {
        editor.replaceSelection("```lapse\n\n```");
      }
    });
    this.addCommand({
      id: "show-lapse-sidebar",
      name: "Show active timers",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new LapseSettingTab(this.app, this));
  }
  async loadEntriesFromFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return;
      }
      const frontmatter = match[1];
      const lines = frontmatter.split("\n");
      const entriesKey = this.settings.entriesKey;
      let inEntries = false;
      let currentEntry = null;
      const entries = [];
      for (let i = 0; i < lines.length; i++) {
        const originalLine = lines[i];
        const trimmed = originalLine.trim();
        const indent = originalLine.length - originalLine.trimStart().length;
        if (trimmed.startsWith(`${entriesKey}:`)) {
          inEntries = true;
          continue;
        }
        if (inEntries) {
          if (trimmed && indent === 0 && !trimmed.startsWith("-")) {
            if (currentEntry) {
              entries.push({
                id: `${filePath}-${entries.length}-${Date.now()}`,
                label: currentEntry.label || "Untitled",
                startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
                endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
                duration: (currentEntry.duration || 0) * 1e3,
                isPaused: false
              });
              currentEntry = null;
            }
            inEntries = false;
            continue;
          }
          if (trimmed.startsWith("- label:")) {
            if (currentEntry) {
              entries.push({
                id: `${filePath}-${entries.length}-${Date.now()}`,
                label: currentEntry.label || "Untitled",
                startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
                endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
                duration: (currentEntry.duration || 0) * 1e3,
                isPaused: false
              });
            }
            currentEntry = {};
            const labelMatch = trimmed.match(/^- label:\s*"?([^"]*)"?/);
            currentEntry.label = labelMatch ? labelMatch[1].trim() : "Untitled";
          } else if (trimmed.startsWith("start:") && currentEntry) {
            currentEntry.start = trimmed.replace(/start:\s*/, "").trim();
          } else if (trimmed.startsWith("end:") && currentEntry) {
            const endValue = trimmed.replace(/end:\s*/, "").trim();
            currentEntry.end = endValue || null;
          } else if (trimmed.startsWith("duration:") && currentEntry) {
            const durationStr = trimmed.replace(/duration:\s*/, "").trim();
            currentEntry.duration = parseInt(durationStr) || 0;
          }
        }
      }
      if (currentEntry) {
        entries.push({
          id: `${filePath}-${entries.length}-${Date.now()}`,
          label: currentEntry.label || "Untitled",
          startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
          endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
          duration: (currentEntry.duration || 0) * 1e3,
          isPaused: false
        });
      }
      if (!this.timeData.has(filePath)) {
        this.timeData.set(filePath, {
          entries: [],
          totalTimeTracked: 0
        });
      }
      const pageData = this.timeData.get(filePath);
      pageData.entries = entries;
      pageData.totalTimeTracked = entries.reduce((sum, e) => sum + e.duration, 0);
    } catch (error) {
      console.error("Error loading entries from frontmatter:", error);
    }
  }
  async getDefaultLabel(filePath) {
    const settings = this.settings;
    if (settings.defaultLabelType === "freeText") {
      return settings.defaultLabelText || "Untitled timer";
    } else if (settings.defaultLabelType === "frontmatter") {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian.TFile)) {
        return "Untitled timer";
      }
      try {
        const content = await this.app.vault.read(file);
        const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
        const match = content.match(frontmatterRegex);
        if (match) {
          const frontmatter = match[1];
          const key = settings.defaultLabelFrontmatterKey;
          const lines = frontmatter.split("\n");
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.startsWith(`${key}:`)) {
              let value = line.replace(new RegExp(`^${key}:\\s*`), "").trim();
              if (!value && i + 1 < lines.length) {
                const nextLine = lines[i + 1].trim();
                if (nextLine.startsWith("-")) {
                  value = nextLine.replace(/^-\s*/, "").trim();
                }
              }
              if (value) {
                value = value.replace(/^["']+|["']+$/g, "");
                value = value.replace(/\[\[|\]\]/g, "");
                value = value.replace(/^[-*•]\s*/, "");
                value = value.trim();
                if (value) {
                  return value;
                }
              }
              break;
            }
          }
        }
      } catch (error) {
        console.error("Error reading frontmatter for default label:", error);
      }
      return "Untitled timer";
    } else if (settings.defaultLabelType === "fileName") {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file && file instanceof import_obsidian.TFile) {
        return file.basename || "Untitled timer";
      }
      return "Untitled timer";
    }
    return "Untitled timer";
  }
  async getProjectFromFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return null;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const frontmatter = match[1];
      const key = this.settings.projectKey;
      const lines = frontmatter.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith(`${key}:`)) {
          let value = line.replace(new RegExp(`^${key}:\\s*`), "").trim();
          if (!value && i + 1 < lines.length) {
            const nextLine = lines[i + 1].trim();
            if (nextLine.startsWith("-")) {
              value = nextLine.replace(/^-\s*/, "").trim();
            }
          }
          if (value) {
            value = value.replace(/^["']+|["']+$/g, "");
            value = value.replace(/\[\[|\]\]/g, "");
            value = value.replace(/^[-*•]\s*/, "");
            value = value.trim();
            if (value) {
              return value;
            }
          }
          break;
        }
      }
    } catch (error) {
      console.error("Error reading frontmatter for project:", error);
    }
    return null;
  }
  async processTimerCodeBlock(source, el, ctx) {
    const filePath = ctx.sourcePath;
    await this.loadEntriesFromFrontmatter(filePath);
    if (!this.timeData.has(filePath)) {
      this.timeData.set(filePath, {
        entries: [],
        totalTimeTracked: 0
      });
    }
    const pageData = this.timeData.get(filePath);
    const activeTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
    const container = el.createDiv({ cls: "lapse-container" });
    const actionBar = container.createDiv({ cls: "lapse-action-bar" });
    const timerContainer = actionBar.createDiv({ cls: "lapse-timer-container" });
    const timerDisplay = timerContainer.createDiv({ cls: "lapse-timer-display" });
    timerDisplay.setText("--:--");
    const adjustButtonsContainer = timerContainer.createDiv({ cls: "lapse-adjust-buttons" });
    const adjustBackBtn = adjustButtonsContainer.createEl("button", { cls: "lapse-btn-adjust" });
    (0, import_obsidian.setIcon)(adjustBackBtn, "chevron-left");
    adjustBackBtn.disabled = !activeTimer;
    const adjustForwardBtn = adjustButtonsContainer.createEl("button", { cls: "lapse-btn-adjust" });
    (0, import_obsidian.setIcon)(adjustForwardBtn, "chevron-right");
    adjustForwardBtn.disabled = !activeTimer;
    const inputContainer = actionBar.createDiv({ cls: "lapse-input-container" });
    let labelDisplay;
    let labelInput = null;
    if (activeTimer) {
      labelDisplay = inputContainer.createEl("div", {
        text: activeTimer.label,
        cls: "lapse-label-display-running"
      });
    } else {
      labelInput = inputContainer.createEl("input", {
        type: "text",
        placeholder: "Timer label...",
        cls: "lapse-label-input"
      });
      labelDisplay = labelInput;
    }
    const summaryLine = inputContainer.createDiv({ cls: "lapse-summary" });
    const summaryLeft = summaryLine.createDiv({ cls: "lapse-summary-left" });
    const summaryRight = summaryLine.createDiv({ cls: "lapse-summary-right" });
    const playStopBtn = actionBar.createEl("button", { cls: "lapse-btn-play-stop" });
    if (activeTimer) {
      (0, import_obsidian.setIcon)(playStopBtn, "square");
    } else {
      (0, import_obsidian.setIcon)(playStopBtn, "play");
    }
    const chevronBtn = actionBar.createEl("button", { cls: "lapse-btn-chevron" });
    (0, import_obsidian.setIcon)(chevronBtn, "chevron-down");
    const calculateTotalTime = () => {
      return pageData.entries.reduce((sum, e) => {
        if (e.endTime !== null) {
          return sum + e.duration;
        } else if (e.startTime !== null) {
          return sum + e.duration + (Date.now() - e.startTime);
        }
        return sum;
      }, 0);
    };
    const calculateTodayTotal = () => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayStart = today.getTime();
      return pageData.entries.reduce((sum, e) => {
        if (e.startTime && e.startTime >= todayStart) {
          if (e.endTime !== null) {
            return sum + e.duration;
          } else if (e.startTime !== null) {
            return sum + e.duration + (Date.now() - e.startTime);
          }
        }
        return sum;
      }, 0);
    };
    const updateDisplays = () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      adjustBackBtn.disabled = !currentActiveTimer;
      adjustForwardBtn.disabled = !currentActiveTimer;
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const elapsed = currentActiveTimer.duration + (Date.now() - currentActiveTimer.startTime);
        timerDisplay.setText(this.formatTimeAsHHMMSS(elapsed));
      } else {
        timerDisplay.setText("--:--");
      }
      const entryCount = pageData.entries.length;
      const totalTime = calculateTotalTime();
      summaryLeft.setText(`${entryCount} ${entryCount === 1 ? "entry" : "entries"}, ${this.formatTimeAsHHMMSS(totalTime)}`);
      const todayTotal = calculateTodayTotal();
      summaryRight.setText(`Today: ${this.formatTimeAsHHMMSS(todayTotal)}`);
    };
    updateDisplays();
    let updateInterval = null;
    if (activeTimer) {
      updateInterval = window.setInterval(updateDisplays, 1e3);
    }
    adjustBackBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const adjustMinutes = this.settings.timeAdjustMinutes;
        const adjustMs = adjustMinutes * 60 * 1e3;
        currentActiveTimer.startTime = currentActiveTimer.startTime - adjustMs;
        await this.updateFrontmatter(filePath);
        updateDisplays();
      }
    };
    adjustForwardBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const adjustMinutes = this.settings.timeAdjustMinutes;
        const adjustMs = adjustMinutes * 60 * 1e3;
        currentActiveTimer.startTime = currentActiveTimer.startTime + adjustMs;
        await this.updateFrontmatter(filePath);
        updateDisplays();
      }
    };
    const panel = container.createDiv({ cls: "lapse-panel" });
    panel.style.display = "none";
    const table = panel.createEl("table", { cls: "lapse-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "Entry" });
    headerRow.createEl("th", { text: "Start" });
    headerRow.createEl("th", { text: "End" });
    headerRow.createEl("th", { text: "Duration" });
    headerRow.createEl("th", { text: "Actions" });
    const tbody = table.createEl("tbody", { cls: "lapse-table-body" });
    this.renderTableRows(tbody, pageData.entries, filePath, labelDisplay, labelInput);
    const addButton = panel.createEl("button", {
      text: "+ Add Entry",
      cls: "lapse-btn-add"
    });
    let isPanelOpen = false;
    chevronBtn.onclick = () => {
      isPanelOpen = !isPanelOpen;
      if (isPanelOpen) {
        panel.style.display = "block";
        (0, import_obsidian.setIcon)(chevronBtn, "chevron-up");
      } else {
        panel.style.display = "none";
        (0, import_obsidian.setIcon)(chevronBtn, "chevron-down");
      }
    };
    playStopBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer) {
        if (!currentActiveTimer.isPaused && currentActiveTimer.startTime) {
          currentActiveTimer.duration += Date.now() - currentActiveTimer.startTime;
        }
        currentActiveTimer.endTime = Date.now();
        currentActiveTimer.isPaused = false;
        if (updateInterval) {
          clearInterval(updateInterval);
          updateInterval = null;
        }
        await this.updateFrontmatter(filePath);
        if (labelInput) {
          labelInput.value = "";
        } else if (labelDisplay) {
          labelDisplay.remove();
          labelInput = inputContainer.createEl("input", {
            type: "text",
            placeholder: "Timer label...",
            cls: "lapse-label-input"
          });
          labelDisplay = labelInput;
        }
        (0, import_obsidian.setIcon)(playStopBtn, "play");
        updateDisplays();
        this.renderTableRows(tbody, pageData.entries, filePath, labelDisplay, labelInput);
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      } else {
        let label = "";
        if (labelInput) {
          label = labelInput.value.trim();
        }
        if (!label) {
          label = await this.getDefaultLabel(filePath);
        }
        const newEntry = {
          id: `${filePath}-${Date.now()}-${Math.random()}`,
          label,
          startTime: Date.now(),
          endTime: null,
          duration: 0,
          isPaused: false
        };
        pageData.entries.push(newEntry);
        if (!updateInterval) {
          updateInterval = window.setInterval(updateDisplays, 1e3);
        }
        await this.updateFrontmatter(filePath);
        if (labelInput) {
          const labelText = labelInput.value;
          labelInput.remove();
          labelDisplay = inputContainer.createEl("div", {
            text: labelText,
            cls: "lapse-label-display-running"
          });
          labelInput = null;
        } else if (labelDisplay) {
          const labelText = labelDisplay.textContent || label;
          labelDisplay.remove();
          labelDisplay = inputContainer.createEl("div", {
            text: labelText,
            cls: "lapse-label-display-running"
          });
        }
        (0, import_obsidian.setIcon)(playStopBtn, "square");
        updateDisplays();
        this.renderTableRows(tbody, pageData.entries, filePath, labelDisplay, labelInput);
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      }
    };
    addButton.onclick = async () => {
      const newEntry = {
        id: `${filePath}-${Date.now()}-${Math.random()}`,
        label: "New Entry",
        startTime: null,
        endTime: null,
        duration: 0,
        isPaused: false
      };
      pageData.entries.push(newEntry);
      await this.updateFrontmatter(filePath);
      this.renderTableRows(tbody, pageData.entries, filePath, labelDisplay, labelInput);
    };
  }
  renderTableRows(tbody, entries, filePath, labelDisplay, labelInput) {
    tbody.empty();
    entries.forEach((entry, index) => {
      const row = tbody.createEl("tr", { cls: "lapse-table-row" });
      const labelCell = row.createEl("td", { cls: "lapse-cell-label" });
      const entryLabelInput = labelCell.createEl("input", {
        type: "text",
        value: entry.label,
        cls: "lapse-input"
      });
      entryLabelInput.readOnly = true;
      const startCell = row.createEl("td", { cls: "lapse-cell-start" });
      const startInput = startCell.createEl("input", {
        type: "datetime-local",
        cls: "lapse-input"
      });
      if (entry.startTime) {
        const date = new Date(entry.startTime);
        startInput.value = this.formatDateTimeLocal(date);
      }
      startInput.readOnly = true;
      const endCell = row.createEl("td", { cls: "lapse-cell-end" });
      const endInput = endCell.createEl("input", {
        type: "datetime-local",
        cls: "lapse-input"
      });
      if (entry.endTime) {
        const date = new Date(entry.endTime);
        endInput.value = this.formatDateTimeLocal(date);
      }
      endInput.readOnly = true;
      const durationCell = row.createEl("td", { cls: "lapse-cell-duration" });
      const durationInput = durationCell.createEl("input", {
        type: "text",
        value: this.formatTimeAsHHMMSS(entry.duration),
        cls: "lapse-input"
      });
      durationInput.readOnly = true;
      const actionsCell = row.createEl("td", { cls: "lapse-cell-actions" });
      const editBtn = actionsCell.createEl("button", { cls: "lapse-btn-edit" });
      const deleteBtn = actionsCell.createEl("button", { cls: "lapse-btn-delete" });
      (0, import_obsidian.setIcon)(editBtn, "pencil");
      (0, import_obsidian.setIcon)(deleteBtn, "trash");
      let isEditing = false;
      editBtn.onclick = async () => {
        if (!isEditing) {
          entryLabelInput.readOnly = false;
          startInput.readOnly = false;
          endInput.readOnly = false;
          (0, import_obsidian.setIcon)(editBtn, "check");
          isEditing = true;
        } else {
          entry.label = entryLabelInput.value;
          const oldStartTime = entry.startTime;
          const oldEndTime = entry.endTime;
          if (startInput.value) {
            entry.startTime = new Date(startInput.value).getTime();
          } else {
            entry.startTime = null;
          }
          if (endInput.value) {
            entry.endTime = new Date(endInput.value).getTime();
          } else {
            entry.endTime = null;
          }
          if (entry.startTime && entry.endTime) {
            entry.duration = entry.endTime - entry.startTime;
          } else if (entry.startTime && !entry.endTime) {
          }
          durationInput.value = this.formatTimeAsHHMMSS(entry.duration);
          entryLabelInput.readOnly = true;
          startInput.readOnly = true;
          endInput.readOnly = true;
          (0, import_obsidian.setIcon)(editBtn, "pencil");
          isEditing = false;
          const isActiveTimer = entry.startTime !== null && entry.endTime === null;
          if (isActiveTimer && labelDisplay) {
            if (labelInput) {
              labelInput.value = entry.label;
            } else {
              labelDisplay.setText(entry.label);
            }
          }
          await this.updateFrontmatter(filePath);
          const pageData = this.timeData.get(filePath);
          if (pageData) {
            this.renderTableRows(tbody, pageData.entries, filePath, labelDisplay, labelInput);
          }
        }
      };
      deleteBtn.onclick = async () => {
        const pageData = this.timeData.get(filePath);
        if (pageData) {
          pageData.entries = pageData.entries.filter((e) => e.id !== entry.id);
          await this.updateFrontmatter(filePath);
          this.renderTableRows(tbody, pageData.entries, filePath, labelDisplay, labelInput);
        }
      };
    });
  }
  formatDateTimeLocal(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }
  formatTimeAsHHMMSS(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1e3);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor(totalSeconds % 3600 / 60);
    const seconds = totalSeconds % 60;
    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }
  async updateFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    const pageData = this.timeData.get(filePath);
    if (!pageData)
      return;
    const content = await this.app.vault.read(file);
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    const startedEntries = pageData.entries.filter((e) => e.startTime !== null);
    const startTime = startedEntries.length > 0 ? Math.min(...startedEntries.map((e) => e.startTime)) : null;
    const completedEntries = pageData.entries.filter((e) => e.endTime !== null);
    const endTime = completedEntries.length > 0 ? Math.max(...completedEntries.map((e) => e.endTime)) : null;
    const entries = pageData.entries.map((entry) => ({
      label: entry.label,
      start: entry.startTime ? new Date(entry.startTime).toISOString() : null,
      end: entry.endTime ? new Date(entry.endTime).toISOString() : null,
      duration: Math.floor(entry.duration / 1e3)
    }));
    const totalTimeTracked = pageData.entries.filter((e) => e.endTime !== null).reduce((sum, e) => sum + e.duration, 0);
    const totalTimeFormatted = this.formatTimeAsHHMMSS(totalTimeTracked);
    let newContent;
    if (match) {
      const existingFrontmatter = match[1];
      const lines = existingFrontmatter.split("\n");
      const startTimeKey = this.settings.startTimeKey;
      const endTimeKey = this.settings.endTimeKey;
      const entriesKey = this.settings.entriesKey;
      const totalTimeKey = this.settings.totalTimeKey;
      let insideEntries = false;
      const filteredLines = [];
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith(`${entriesKey}:`)) {
          insideEntries = true;
          continue;
        }
        if (insideEntries) {
          if (line.match(/^\s+/)) {
            continue;
          }
          insideEntries = false;
        }
        if (trimmed.startsWith(`${startTimeKey}:`) || trimmed.startsWith(`${endTimeKey}:`) || trimmed.startsWith(`${totalTimeKey}:`)) {
          continue;
        }
        filteredLines.push(line);
      }
      if (startTime !== null) {
        filteredLines.push(`${startTimeKey}: ${new Date(startTime).toISOString()}`);
      }
      if (endTime !== null) {
        filteredLines.push(`${endTimeKey}: ${new Date(endTime).toISOString()}`);
      }
      if (entries.length > 0) {
        filteredLines.push(`${entriesKey}:`);
        entries.forEach((entry) => {
          filteredLines.push(`  - label: "${entry.label.replace(/"/g, '\\"')}"`);
          if (entry.start) {
            filteredLines.push(`    start: ${entry.start}`);
          }
          if (entry.end) {
            filteredLines.push(`    end: ${entry.end}`);
          }
          filteredLines.push(`    duration: ${entry.duration}`);
        });
      } else {
        filteredLines.push(`${entriesKey}: []`);
      }
      filteredLines.push(`${totalTimeKey}: "${totalTimeFormatted}"`);
      newContent = content.replace(frontmatterRegex, `---
${filteredLines.join("\n")}
---`);
    } else {
      const startTimeKey = this.settings.startTimeKey;
      const endTimeKey = this.settings.endTimeKey;
      const entriesKey = this.settings.entriesKey;
      const totalTimeKey = this.settings.totalTimeKey;
      const frontmatterLines = [];
      if (startTime !== null) {
        frontmatterLines.push(`${startTimeKey}: ${new Date(startTime).toISOString()}`);
      }
      if (endTime !== null) {
        frontmatterLines.push(`${endTimeKey}: ${new Date(endTime).toISOString()}`);
      }
      if (entries.length > 0) {
        frontmatterLines.push(`${entriesKey}:`);
        entries.forEach((entry) => {
          frontmatterLines.push(`  - label: "${entry.label.replace(/"/g, '\\"')}"`);
          if (entry.start) {
            frontmatterLines.push(`    start: ${entry.start}`);
          }
          if (entry.end) {
            frontmatterLines.push(`    end: ${entry.end}`);
          }
          frontmatterLines.push(`    duration: ${entry.duration}`);
        });
      } else {
        frontmatterLines.push(`${entriesKey}: []`);
      }
      frontmatterLines.push(`${totalTimeKey}: "${totalTimeFormatted}"`);
      const frontmatter = `---
${frontmatterLines.join("\n")}
---

`;
      newContent = frontmatter + content;
    }
    await this.app.vault.modify(file, newContent);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType("lapse-sidebar");
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: "lapse-sidebar", active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async getActiveTimers() {
    const activeTimers = [];
    this.timeData.forEach((pageData, filePath) => {
      pageData.entries.forEach((entry) => {
        if (entry.startTime && !entry.endTime) {
          activeTimers.push({ filePath, entry });
        }
      });
    });
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (this.timeData.has(filePath)) {
        continue;
      }
      await this.loadEntriesFromFrontmatter(filePath);
      const pageData = this.timeData.get(filePath);
      if (pageData) {
        pageData.entries.forEach((entry) => {
          if (entry.startTime && !entry.endTime) {
            activeTimers.push({ filePath, entry });
          }
        });
      }
    }
    return activeTimers;
  }
  onunload() {
    console.log("Unloading Lapse plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var LapseSidebarView = class extends import_obsidian.ItemView {
  // Map of entry ID to time display element
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshInterval = null;
    this.timeDisplays = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  getViewType() {
    return "lapse-sidebar";
  }
  getDisplayText() {
    return "Active Timers";
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    await this.render();
  }
  async render() {
    var _a, _b;
    const container = this.containerEl.children[1];
    container.empty();
    this.timeDisplays.clear();
    container.createEl("h4", { text: "Active Timers" });
    const activeTimers = await this.plugin.getActiveTimers();
    if (activeTimers.length === 0) {
      container.createEl("p", { text: "No active timers", cls: "lapse-sidebar-empty" });
    } else {
      const list = container.createEl("ul", { cls: "lapse-sidebar-list" });
      for (const { filePath, entry } of activeTimers) {
        const item = list.createEl("li", { cls: "lapse-sidebar-item" });
        const topLine = item.createDiv({ cls: "lapse-sidebar-top-line" });
        const file = this.app.vault.getAbstractFileByPath(filePath);
        const fileName = file && file instanceof import_obsidian.TFile ? file.basename : ((_a = filePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || filePath;
        const link = topLine.createEl("a", {
          text: fileName,
          cls: "internal-link",
          href: filePath
        });
        link.onclick = (e) => {
          e.preventDefault();
          const file2 = this.app.vault.getAbstractFileByPath(filePath);
          if (file2 && file2 instanceof import_obsidian.TFile) {
            this.app.workspace.openLinkText(filePath, "", false);
          }
        };
        const elapsed = entry.duration + (entry.isPaused ? 0 : Date.now() - entry.startTime);
        const timeText = this.plugin.formatTimeAsHHMMSS(elapsed);
        const timeDisplay = topLine.createSpan({ text: timeText, cls: "lapse-sidebar-time" });
        this.timeDisplays.set(entry.id, timeDisplay);
        const project = await this.plugin.getProjectFromFrontmatter(filePath);
        const secondLine = item.createDiv({ cls: "lapse-sidebar-second-line" });
        if (project) {
          secondLine.createSpan({ text: project, cls: "lapse-sidebar-project" });
        }
        secondLine.createSpan({ text: entry.label, cls: "lapse-sidebar-label" });
      }
    }
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayStart = today.getTime();
    const todayEntries = [];
    this.plugin.timeData.forEach((pageData, filePath) => {
      pageData.entries.forEach((entry) => {
        if (entry.startTime && entry.startTime >= todayStart && entry.endTime) {
          todayEntries.push({ filePath, entry, startTime: entry.startTime });
        }
      });
    });
    const entriesByNote = /* @__PURE__ */ new Map();
    todayEntries.forEach(({ filePath, entry, startTime }) => {
      if (!entriesByNote.has(filePath)) {
        entriesByNote.set(filePath, []);
      }
      entriesByNote.get(filePath).push({ entry, startTime });
    });
    entriesByNote.forEach((entries) => {
      entries.sort((a, b) => b.startTime - a.startTime);
    });
    const noteGroups = Array.from(entriesByNote.entries()).map(([filePath, entries]) => {
      const totalTime = entries.reduce((sum, { entry }) => sum + entry.duration, 0);
      const newestStartTime = Math.max(...entries.map((e) => e.startTime));
      return { filePath, entries, totalTime, newestStartTime };
    });
    noteGroups.sort((a, b) => b.newestStartTime - a.newestStartTime);
    if (noteGroups.length > 0) {
      container.createEl("h4", { text: "Today's Entries", cls: "lapse-sidebar-section-title" });
      const todayList = container.createEl("ul", { cls: "lapse-sidebar-list" });
      for (const { filePath, entries, totalTime } of noteGroups) {
        const item = todayList.createEl("li", { cls: "lapse-sidebar-note-group" });
        const topLine = item.createDiv({ cls: "lapse-sidebar-top-line" });
        const file = this.app.vault.getAbstractFileByPath(filePath);
        const fileName = file && file instanceof import_obsidian.TFile ? file.basename : ((_b = filePath.split("/").pop()) == null ? void 0 : _b.replace(".md", "")) || filePath;
        const link = topLine.createEl("a", {
          text: fileName,
          cls: "internal-link",
          href: filePath
        });
        link.onclick = (e) => {
          e.preventDefault();
          const file2 = this.app.vault.getAbstractFileByPath(filePath);
          if (file2 && file2 instanceof import_obsidian.TFile) {
            this.app.workspace.openLinkText(filePath, "", false);
          }
        };
        const timeText = this.plugin.formatTimeAsHHMMSS(totalTime);
        topLine.createSpan({ text: timeText, cls: "lapse-sidebar-time" });
        const project = await this.plugin.getProjectFromFrontmatter(filePath);
        if (project) {
          const secondLine = item.createDiv({ cls: "lapse-sidebar-second-line" });
          secondLine.createSpan({ text: project, cls: "lapse-sidebar-project" });
        }
        const entriesList = item.createDiv({ cls: "lapse-sidebar-entries-list" });
        entries.forEach(({ entry }) => {
          const entryLine = entriesList.createDiv({ cls: "lapse-sidebar-entry-line" });
          const entryTime = this.plugin.formatTimeAsHHMMSS(entry.duration);
          entryLine.createSpan({ text: entry.label, cls: "lapse-sidebar-entry-label" });
          entryLine.createSpan({ text: entryTime, cls: "lapse-sidebar-entry-time" });
        });
      }
    }
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    if (activeTimers.length > 0) {
      this.refreshInterval = window.setInterval(() => this.updateTimers(), 1e3);
    } else {
      this.refreshInterval = null;
    }
  }
  updateTimers() {
    this.timeDisplays.forEach((timeDisplay, entryId) => {
      let foundEntry = null;
      let found = false;
      for (const [filePath, pageData] of this.plugin.timeData) {
        for (const entry of pageData.entries) {
          if (entry.id === entryId && entry.startTime && !entry.endTime) {
            foundEntry = entry;
            found = true;
            break;
          }
        }
        if (found)
          break;
      }
      if (foundEntry && foundEntry.startTime) {
        const elapsed = foundEntry.duration + (foundEntry.isPaused ? 0 : Date.now() - foundEntry.startTime);
        const timeText = this.plugin.formatTimeAsHHMMSS(elapsed);
        timeDisplay.setText(timeText);
      } else {
        this.timeDisplays.delete(entryId);
      }
    });
    if (this.timeDisplays.size === 0 && this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
      this.render();
    }
  }
  async refresh() {
    await this.render();
  }
  async onClose() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }
};
var LapseSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Lapse Settings" });
    new import_obsidian.Setting(containerEl).setName("Show seconds").setDesc("Display seconds in timer").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSeconds).onChange(async (value) => {
      this.plugin.settings.showSeconds = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Frontmatter Keys" });
    new import_obsidian.Setting(containerEl).setName("Start Time Key").setDesc("Frontmatter key for start time").addText((text) => text.setPlaceholder("startTime").setValue(this.plugin.settings.startTimeKey).onChange(async (value) => {
      this.plugin.settings.startTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("End Time Key").setDesc("Frontmatter key for end time").addText((text) => text.setPlaceholder("endTime").setValue(this.plugin.settings.endTimeKey).onChange(async (value) => {
      this.plugin.settings.endTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Total Time Key").setDesc("Frontmatter key for total time tracked").addText((text) => text.setPlaceholder("totalTimeTracked").setValue(this.plugin.settings.totalTimeKey).onChange(async (value) => {
      this.plugin.settings.totalTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Project Key").setDesc("Frontmatter key for project name").addText((text) => text.setPlaceholder("project").setValue(this.plugin.settings.projectKey).onChange(async (value) => {
      this.plugin.settings.projectKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Default Time Entry Label" });
    new import_obsidian.Setting(containerEl).setName("Label Type").setDesc("How to determine the default label for new time entries").addDropdown((dropdown) => dropdown.addOption("freeText", "Free Text").addOption("frontmatter", "Frontmatter").addOption("fileName", "File Name").setValue(this.plugin.settings.defaultLabelType).onChange(async (value) => {
      this.plugin.settings.defaultLabelType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.defaultLabelType === "freeText") {
      new import_obsidian.Setting(containerEl).setName("Default Label Text").setDesc("Default text to use for new time entries").addText((text) => text.setPlaceholder("Enter default label").setValue(this.plugin.settings.defaultLabelText).onChange(async (value) => {
        this.plugin.settings.defaultLabelText = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.defaultLabelType === "frontmatter") {
      new import_obsidian.Setting(containerEl).setName("Frontmatter Key").setDesc("Frontmatter key to use for default label").addText((text) => text.setPlaceholder("project").setValue(this.plugin.settings.defaultLabelFrontmatterKey).onChange(async (value) => {
        this.plugin.settings.defaultLabelFrontmatterKey = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Timer Controls" });
    new import_obsidian.Setting(containerEl).setName("Time Adjust Minutes").setDesc("Number of minutes to adjust start time when using << or >> buttons").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.timeAdjustMinutes.toString()).onChange(async (value) => {
      const numValue = parseInt(value) || 5;
      this.plugin.settings.timeAdjustMinutes = numValue;
      await this.plugin.saveSettings();
    }));
  }
};
