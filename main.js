/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LapsePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  dateFormat: "YYYY-MM-DD HH:mm:ss",
  showSeconds: true,
  startTimeKey: "startTime",
  endTimeKey: "endTime",
  entriesKey: "lapseEntries",
  totalTimeKey: "totalTimeTracked",
  projectKey: "project",
  defaultLabelType: "freeText",
  defaultLabelText: "",
  defaultLabelFrontmatterKey: "project",
  removeTimestampFromFileName: false,
  hideTimestampsInViews: true,
  defaultTagOnNote: "#lapse",
  defaultTagOnTimeEntries: "",
  timeAdjustMinutes: 5,
  firstDayOfWeek: 0,
  // 0 = Sunday
  excludedFolders: [],
  // No folders excluded by default
  showStatusBar: true,
  // Show active timers in status bar by default
  lapseButtonTemplatesFolder: "Templates/Lapse Buttons",
  // Default folder for lapse button templates
  showDurationOnNoteButtons: false,
  // Don't show duration on note buttons by default
  noteButtonDurationType: "note",
  // Default to note
  noteButtonTimePeriod: "today"
  // Default to today
};
var LapsePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.timeData = /* @__PURE__ */ new Map();
    this.entryCache = {};
    // In-memory cache indexed by file path (lazy-loaded)
    this.cacheSaveTimeout = null;
    // Debounce cache saves
    this.statusBarItem = null;
    // Status bar element
    this.statusBarUpdateInterval = null;
    // Interval for updating status bar
    this.pendingSaves = [];
  }
  // Track pending save operations
  async onload() {
    const pluginStartTime = Date.now();
    await this.loadSettings();
    console.log(`Lapse: Plugin loading... (${Date.now() - pluginStartTime}ms)`);
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        this.invalidateCacheForFile(file.path);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        this.invalidateCacheForFile(file.path);
        this.timeData.delete(file.path);
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        this.invalidateCacheForFile(oldPath);
        this.timeData.delete(oldPath);
      })
    );
    this.registerMarkdownCodeBlockProcessor("lapse", this.processTimerCodeBlock.bind(this));
    this.registerMarkdownCodeBlockProcessor("lapse-report", this.processReportCodeBlock.bind(this));
    this.registerMarkdownCodeBlockProcessor("lapse-active", this.processActiveTimersCodeBlock.bind(this));
    this.registerMarkdownPostProcessor((el, ctx) => {
      const codeElements = el.querySelectorAll("code:not(pre code)");
      codeElements.forEach((codeEl) => {
        var _a;
        if (codeEl instanceof HTMLElement) {
          const text = codeEl.textContent || "";
          if (text.startsWith("lapse:")) {
            const templateName = text.substring("lapse:".length);
            if (!((_a = codeEl.parentElement) == null ? void 0 : _a.classList.contains("lapse-button"))) {
              this.processLapseButton(codeEl, templateName, ctx).catch((err) => {
                console.error("Error processing lapse button:", err);
              });
            }
          }
        }
      });
    });
    this.registerView(
      "lapse-sidebar",
      (leaf) => new LapseSidebarView(leaf, this)
    );
    this.registerView(
      "lapse-reports",
      (leaf) => new LapseReportsView(leaf, this)
    );
    this.registerView(
      "lapse-buttons",
      (leaf) => new LapseButtonsView(leaf, this)
    );
    this.addRibbonIcon("clock", "Lapse: Show Activity", () => {
      this.activateView();
    });
    this.addRibbonIcon("bar-chart-2", "Lapse: Show Time Reports", () => {
      this.activateReportsView();
    });
    this.addRibbonIcon("play-circle", "Lapse: Show Quick Start", () => {
      this.activateButtonsView();
    });
    this.addCommand({
      id: "insert-lapse-timer",
      name: "Add time tracker",
      editorCallback: (editor) => {
        editor.replaceSelection("```lapse\n\n```");
      },
      hotkeys: []
    });
    this.addCommand({
      id: "insert-lapse-autostart",
      name: "Add and start time tracker",
      editorCallback: async (editor, view) => {
        const file = view.file;
        if (!file)
          return;
        const filePath = file.path;
        editor.replaceSelection("```lapse\n\n```");
        if (!this.timeData.has(filePath)) {
          this.timeData.set(filePath, {
            entries: [],
            totalTimeTracked: 0
          });
        }
        const pageData = this.timeData.get(filePath);
        const hasActiveTimer = pageData.entries.some((e) => e.startTime !== null && e.endTime === null);
        if (!hasActiveTimer) {
          const label = await this.getDefaultLabel(filePath);
          const newEntry = {
            id: `${filePath}-${Date.now()}-${Math.random()}`,
            label,
            startTime: Date.now(),
            endTime: null,
            duration: 0,
            isPaused: false,
            tags: this.getDefaultTags()
          };
          pageData.entries.push(newEntry);
          await this.addDefaultTagToNote(filePath);
          await this.updateFrontmatter(filePath);
          this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
            if (leaf.view instanceof LapseSidebarView) {
              leaf.view.refresh();
            }
          });
        }
        const activeLeaf = this.app.workspace.activeLeaf;
        if (activeLeaf && activeLeaf.view.getViewType() === "markdown") {
          const state = activeLeaf.view.getState();
          await activeLeaf.setViewState({
            type: "markdown",
            // @ts-ignore - state has mode property
            state: { ...state, mode: "preview" }
          });
        }
      },
      hotkeys: []
    });
    this.addCommand({
      id: "quick-start-timer",
      name: "Quick start timer",
      editorCallback: async (editor, view) => {
        const file = view.file;
        if (!file)
          return;
        const filePath = file.path;
        const pageData = this.timeData.get(filePath);
        const hasActiveTimer = pageData == null ? void 0 : pageData.entries.some((e) => e.startTime !== null && e.endTime === null);
        if (hasActiveTimer) {
          const activeEntry = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
          if (activeEntry) {
            activeEntry.endTime = Date.now();
            activeEntry.duration += activeEntry.endTime - activeEntry.startTime;
            await this.updateFrontmatter(filePath);
            this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
              if (leaf.view instanceof LapseSidebarView) {
                leaf.view.refresh();
              }
            });
          }
        } else {
          const label = await this.getDefaultLabel(filePath);
          const newEntry = {
            id: `${filePath}-${Date.now()}-${Math.random()}`,
            label,
            startTime: Date.now(),
            endTime: null,
            duration: 0,
            isPaused: false,
            tags: this.getDefaultTags()
          };
          if (!this.timeData.has(filePath)) {
            this.timeData.set(filePath, {
              entries: [],
              totalTimeTracked: 0
            });
          }
          const data = this.timeData.get(filePath);
          data.entries.push(newEntry);
          await this.addDefaultTagToNote(filePath);
          await this.updateFrontmatter(filePath);
          this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
            if (leaf.view instanceof LapseSidebarView) {
              leaf.view.refresh();
            }
          });
        }
        const activeLeaf = this.app.workspace.activeLeaf;
        if (activeLeaf && activeLeaf.view.getViewType() === "markdown") {
          const state = activeLeaf.view.getState();
          const currentMode = state.mode || "source";
          const tempMode = currentMode === "source" ? "preview" : "source";
          await activeLeaf.setViewState({
            type: "markdown",
            // @ts-ignore
            state: { ...state, mode: tempMode }
          });
          setTimeout(async () => {
            await activeLeaf.setViewState({
              type: "markdown",
              // @ts-ignore
              state: { ...state, mode: currentMode }
            });
          }, 50);
        }
      }
    });
    this.addCommand({
      id: "show-lapse-sidebar",
      name: "Show activity",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "show-lapse-reports",
      name: "Show time reports",
      callback: () => {
        this.activateReportsView();
      }
    });
    this.addCommand({
      id: "show-lapse-buttons",
      name: "Show quick start",
      callback: () => {
        this.activateButtonsView();
      }
    });
    this.addCommand({
      id: "insert-lapse-button",
      name: "Insert template button",
      editorCallback: (editor) => {
        new LapseButtonModal(this.app, this, (templateName) => {
          editor.replaceSelection(`\`lapse:${templateName}\``);
        }).open();
      }
    });
    this.addSettingTab(new LapseSettingTab(this.app, this));
    if (this.settings.showStatusBar) {
      this.statusBarItem = this.addStatusBarItem();
      this.statusBarItem.addClass("lapse-status-bar");
      this.updateStatusBar();
      this.statusBarUpdateInterval = window.setInterval(() => {
        this.updateStatusBar();
      }, 1e3);
    }
    const totalLoadTime = Date.now() - pluginStartTime;
    console.log(`Lapse: Plugin loaded in ${totalLoadTime}ms`);
  }
  updateStatusBar() {
    if (!this.settings.showStatusBar || !this.statusBarItem) {
      return;
    }
    const activeTimers = [];
    for (const [filePath, pageData] of this.timeData) {
      for (const entry of pageData.entries) {
        if (entry.startTime !== null && entry.endTime === null) {
          activeTimers.push({ filePath, entry });
        }
      }
    }
    if (activeTimers.length === 0) {
      this.statusBarItem.setText("");
      this.statusBarItem.hide();
    } else if (activeTimers.length === 1) {
      const { entry } = activeTimers[0];
      const elapsed = entry.duration + (Date.now() - entry.startTime);
      const timeText = this.formatTimeForTimerDisplay(elapsed);
      this.statusBarItem.setText(`${entry.label} - ${timeText}`);
      this.statusBarItem.show();
    } else {
      let totalElapsed = 0;
      for (const { entry } of activeTimers) {
        totalElapsed += entry.duration + (Date.now() - entry.startTime);
      }
      const timeText = this.formatTimeForTimerDisplay(totalElapsed);
      this.statusBarItem.setText(`${activeTimers.length} timers - ${timeText}`);
      this.statusBarItem.show();
    }
  }
  async loadEntriesFromFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return;
      }
      const frontmatter = match[1];
      const lines = frontmatter.split("\n");
      const entriesKey = this.settings.entriesKey;
      let inEntries = false;
      let currentEntry = null;
      const entries = [];
      for (let i = 0; i < lines.length; i++) {
        const originalLine = lines[i];
        const trimmed = originalLine.trim();
        const indent = originalLine.length - originalLine.trimStart().length;
        if (trimmed.startsWith(`${entriesKey}:`)) {
          inEntries = true;
          continue;
        }
        if (inEntries) {
          if (trimmed && indent === 0 && !trimmed.startsWith("-")) {
            if (currentEntry) {
              entries.push({
                id: `${filePath}-${entries.length}-${Date.now()}`,
                label: currentEntry.label || "Untitled",
                startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
                endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
                duration: (currentEntry.duration || 0) * 1e3,
                isPaused: false,
                tags: currentEntry.tags || []
              });
              currentEntry = null;
            }
            inEntries = false;
            continue;
          }
          if (trimmed.startsWith("- label:")) {
            if (currentEntry) {
              entries.push({
                id: `${filePath}-${entries.length}-${Date.now()}`,
                label: currentEntry.label || "Untitled",
                startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
                endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
                duration: (currentEntry.duration || 0) * 1e3,
                isPaused: false,
                tags: currentEntry.tags || []
              });
            }
            currentEntry = {};
            const labelMatch = trimmed.match(/^- label:\s*"?([^"]*)"?/);
            currentEntry.label = labelMatch ? labelMatch[1].trim() : "Untitled";
          } else if (trimmed.startsWith("start:") && currentEntry) {
            currentEntry.start = trimmed.replace(/start:\s*/, "").trim();
          } else if (trimmed.startsWith("end:") && currentEntry) {
            const endValue = trimmed.replace(/end:\s*/, "").trim();
            currentEntry.end = endValue || null;
          } else if (trimmed.startsWith("duration:") && currentEntry) {
            const durationStr = trimmed.replace(/duration:\s*/, "").trim();
            currentEntry.duration = parseInt(durationStr) || 0;
          } else if (trimmed.startsWith("tags:") && currentEntry) {
            const tagsStr = trimmed.replace(/tags:\s*/, "").trim();
            if (tagsStr.startsWith("[")) {
              try {
                currentEntry.tags = JSON.parse(tagsStr);
              } catch (e) {
                currentEntry.tags = [];
              }
            } else if (tagsStr) {
              currentEntry.tags = tagsStr.split(",").map((t) => t.trim()).filter((t) => t);
            } else {
              currentEntry.tags = [];
              let j = i + 1;
              while (j < lines.length) {
                const nextLine = lines[j];
                const nextTrimmed = nextLine.trim();
                const nextIndent = nextLine.length - nextLine.trimStart().length;
                if (nextTrimmed.startsWith("-") && nextIndent > indent) {
                  const tagValue = nextTrimmed.substring(1).trim();
                  const cleanTag = tagValue.replace(/^["'](.*)["']$/, "$1");
                  if (cleanTag) {
                    currentEntry.tags.push(cleanTag);
                  }
                  j++;
                } else if (nextTrimmed === "") {
                  j++;
                } else {
                  break;
                }
              }
              i = j - 1;
            }
          }
        }
      }
      if (currentEntry) {
        entries.push({
          id: `${filePath}-${entries.length}-${Date.now()}`,
          label: currentEntry.label || "Untitled",
          startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
          endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
          duration: (currentEntry.duration || 0) * 1e3,
          isPaused: false,
          tags: currentEntry.tags || []
        });
      }
      if (!this.timeData.has(filePath)) {
        this.timeData.set(filePath, {
          entries: [],
          totalTimeTracked: 0
        });
      }
      const pageData = this.timeData.get(filePath);
      pageData.entries = entries;
      pageData.totalTimeTracked = entries.reduce((sum, e) => sum + e.duration, 0);
    } catch (error) {
      console.error("Error loading entries from frontmatter:", error);
    }
  }
  getDefaultTags() {
    const defaultTag = this.settings.defaultTagOnTimeEntries.trim();
    if (defaultTag) {
      const tag = defaultTag.startsWith("#") ? defaultTag.substring(1) : defaultTag;
      return [tag];
    }
    return [];
  }
  async addDefaultTagToNote(filePath) {
    const defaultTag = this.settings.defaultTagOnNote.trim();
    if (!defaultTag) {
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      const tagName = defaultTag.startsWith("#") ? defaultTag.substring(1) : defaultTag;
      if (match) {
        const frontmatter = match[1];
        if (frontmatter.includes(`tags:`) || frontmatter.includes(`tag:`)) {
          const tagsMatch = frontmatter.match(/tags?:\s*\[?([^\]\n]+)\]?/);
          if (tagsMatch) {
            const existingTags = tagsMatch[1].split(",").map((t) => t.trim().replace(/['"#]/g, ""));
            if (existingTags.includes(tagName)) {
              return;
            }
          }
          const newContent = content.replace(
            /(^tags?:\s*)(.+?)$/m,
            (match2, prefix, existingTagsStr) => {
              let tagList = [];
              const arrayMatch = existingTagsStr.match(/\[(.+)\]/);
              if (arrayMatch) {
                tagList = arrayMatch[1].split(",").map((t) => t.trim().replace(/['"#]/g, "")).filter((t) => t);
              } else {
                tagList = existingTagsStr.split(/[\s,]+/).map((t) => t.trim().replace(/['"#]/g, "")).filter((t) => t);
              }
              if (!tagList.includes(tagName)) {
                tagList.push(tagName);
              }
              return `${prefix}[${tagList.map((t) => `"${t}"`).join(", ")}]`;
            }
          );
          await this.app.vault.modify(file, newContent);
        } else {
          const newFrontmatter = frontmatter + `
tags: ["${tagName}"]`;
          const newContent = content.replace(frontmatterRegex, `---
${newFrontmatter}
---`);
          await this.app.vault.modify(file, newContent);
        }
      } else {
        const newContent = `---
tags: ["${tagName}"]
---

${content}`;
        await this.app.vault.modify(file, newContent);
      }
    } catch (error) {
      console.error("Error adding tag to note:", error);
    }
  }
  async getDefaultLabel(filePath) {
    const settings = this.settings;
    if (settings.defaultLabelType === "freeText") {
      return settings.defaultLabelText || "Untitled timer";
    } else if (settings.defaultLabelType === "frontmatter") {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian.TFile)) {
        return "Untitled timer";
      }
      try {
        const content = await this.app.vault.read(file);
        const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
        const match = content.match(frontmatterRegex);
        if (match) {
          const frontmatter = match[1];
          const key = settings.defaultLabelFrontmatterKey;
          const lines = frontmatter.split("\n");
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.startsWith(`${key}:`)) {
              let value = line.replace(new RegExp(`^${key}:\\s*`), "").trim();
              if (!value && i + 1 < lines.length) {
                const nextLine = lines[i + 1].trim();
                if (nextLine.startsWith("-")) {
                  value = nextLine.replace(/^-\s*/, "").trim();
                }
              }
              if (value) {
                value = value.replace(/^["']+|["']+$/g, "");
                value = value.replace(/\[\[|\]\]/g, "");
                value = value.replace(/^[-*•]\s*/, "");
                value = value.trim();
                if (value) {
                  return value;
                }
              }
              break;
            }
          }
        }
      } catch (error) {
        console.error("Error reading frontmatter for default label:", error);
      }
      return "Untitled timer";
    } else if (settings.defaultLabelType === "fileName") {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file && file instanceof import_obsidian.TFile) {
        let fileName = file.basename || "Untitled timer";
        if (settings.removeTimestampFromFileName) {
          fileName = this.removeTimestampFromFileName(fileName);
        }
        return fileName;
      }
      return "Untitled timer";
    }
    return "Untitled timer";
  }
  removeTimestampFromFileName(fileName) {
    let result = fileName;
    result = result.replace(/(?:^|[-_\s])(\d{8})-(\d{4,6})(?:[-_\s]|$)/g, "");
    result = result.replace(/(?:^|[-_\s])(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}(?::\d{2})?(?:\.\d{3})?)(?:Z|[-+]\d{2}:\d{2})?(?:[-_\s]|$)/gi, "");
    result = result.replace(/(?:^|[-_\s])(\d{4}-\d{2}-\d{2})[-_\s](\d{2}:\d{2}(?::\d{2})?)(?:[-_\s]|$)/g, "");
    result = result.replace(/(?:^|[-_\s])(\d{4}[-/]?\d{2}[-/]?\d{2})(?:[-_\s]|$)/g, "");
    result = result.replace(/(?:^|[-_\s])(\d{2}:\d{2}(?::\d{2})?)(?:[-_\s]|$)/g, "");
    result = result.replace(/[-_\s]{2,}/g, " ");
    result = result.replace(/^[-_\s]+|[-_\s]+$/g, "");
    result = result.trim();
    return result || fileName;
  }
  patternToRegex(pattern) {
    pattern = pattern.replace(/\\/g, "/");
    pattern = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
    pattern = pattern.replace(/\*\*/g, "<<<DOUBLESTAR>>>");
    pattern = pattern.replace(/\*/g, "[^/]*");
    pattern = pattern.replace(/<<<DOUBLESTAR>>>/g, ".*");
    return new RegExp("^" + pattern);
  }
  isFileExcluded(filePath) {
    if (this.settings.excludedFolders.length === 0) {
      return false;
    }
    const normalizedPath = filePath.replace(/\\/g, "/");
    return this.settings.excludedFolders.some((pattern) => {
      if (!pattern.trim())
        return false;
      const regex = this.patternToRegex(pattern);
      return regex.test(normalizedPath);
    });
  }
  async getProjectFromFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return null;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const frontmatter = match[1];
      const key = this.settings.projectKey;
      const lines = frontmatter.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith(`${key}:`)) {
          let value = line.replace(new RegExp(`^${key}:\\s*`), "").trim();
          if (!value && i + 1 < lines.length) {
            const nextLine = lines[i + 1].trim();
            if (nextLine.startsWith("-")) {
              value = nextLine.replace(/^-\s*/, "").trim();
            }
          }
          if (value) {
            value = value.replace(/^["']+|["']+$/g, "");
            value = value.replace(/\[\[|\]\]/g, "");
            value = value.replace(/^[-*•]\s*/, "");
            value = value.trim();
            if (value) {
              return value;
            }
          }
          break;
        }
      }
    } catch (error) {
      console.error("Error reading frontmatter for project:", error);
    }
    return null;
  }
  async processLapseButton(codeEl, templateName, ctx) {
    try {
      const templatePath = `${this.settings.lapseButtonTemplatesFolder}/${templateName}.md`;
      const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
      if (!templateFile || !(templateFile instanceof import_obsidian.TFile)) {
        const errorBtn = document.createElement("button");
        errorBtn.className = "lapse-button lapse-button-error";
        errorBtn.textContent = `\u26A0\uFE0F Template not found: ${templateName}`;
        errorBtn.title = `Looking for: ${templatePath}`;
        errorBtn.disabled = true;
        codeEl.replaceWith(errorBtn);
        return;
      }
      let project = null;
      try {
        const content = await this.app.vault.read(templateFile);
        const frontmatterRegex = /---\n([\s\S]*?)\n---/;
        const match = content.match(frontmatterRegex);
        if (match) {
          const frontmatter = match[1];
          const lines = frontmatter.split("\n");
          for (const line of lines) {
            if (line.trim().startsWith(this.settings.projectKey + ":")) {
              project = line.split(":").slice(1).join(":").trim();
              if (project) {
                project = project.replace(/\[\[/g, "").replace(/\]\]/g, "");
                project = project.replace(/^["']+|["']+$/g, "");
                project = project.trim();
              }
              break;
            }
          }
        }
      } catch (error) {
        console.error("Error reading template:", error);
      }
      let projectColor = null;
      if (project) {
        projectColor = await this.getProjectColor(project);
      }
      const button = document.createElement("button");
      button.className = "lapse-button";
      const topLine = document.createElement("div");
      topLine.className = "lapse-button-name";
      topLine.style.display = "flex";
      topLine.style.justifyContent = "flex-start";
      topLine.style.alignItems = "center";
      topLine.style.gap = "8px";
      topLine.style.minWidth = "0";
      const titleEl = document.createElement("span");
      titleEl.className = "lapse-button-title";
      titleEl.textContent = templateName;
      titleEl.style.overflow = "hidden";
      titleEl.style.textOverflow = "ellipsis";
      titleEl.style.whiteSpace = "nowrap";
      titleEl.style.flex = "1";
      titleEl.style.minWidth = "0";
      topLine.appendChild(titleEl);
      if (this.settings.showDurationOnNoteButtons) {
        try {
          const duration = await this.getTemplateButtonDuration(templateName, project);
          if (duration > 0) {
            const durationText = this.formatTimeForButton(duration);
            const durationEl = document.createElement("span");
            durationEl.className = "lapse-button-duration";
            durationEl.textContent = durationText;
            durationEl.style.flexShrink = "0";
            durationEl.style.marginLeft = "auto";
            topLine.appendChild(durationEl);
          }
        } catch (error) {
          console.error("Error calculating duration:", error);
        }
      }
      button.appendChild(topLine);
      if (project) {
        const bottomLine = document.createElement("div");
        bottomLine.className = "lapse-button-project";
        bottomLine.textContent = project;
        button.appendChild(bottomLine);
      }
      if (projectColor) {
        button.style.borderLeftColor = projectColor;
        if (project) {
          const bottomLine = button.querySelector(".lapse-button-project");
          if (bottomLine) {
            bottomLine.style.backgroundColor = projectColor;
            const contrastColor = this.getContrastColor(projectColor);
            bottomLine.style.color = contrastColor;
          }
        }
      }
      button.onclick = async () => {
        try {
          const templateContent = await this.app.vault.read(templateFile);
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
          const newNoteName = `${templateName} ${timestamp}`;
          const newNotePath = `${newNoteName}.md`;
          const newFile = await this.app.vault.create(newNotePath, templateContent);
          await this.app.workspace.getLeaf(false).openFile(newFile);
        } catch (error) {
          console.error("Error creating note from template:", error);
        }
      };
      codeEl.replaceWith(button);
    } catch (error) {
      console.error("Error processing lapse button:", error);
      const errorBtn = document.createElement("button");
      errorBtn.className = "lapse-button lapse-button-error";
      errorBtn.textContent = `\u26A0\uFE0F Error: ${templateName}`;
      errorBtn.title = `Error processing button: ${error}`;
      errorBtn.disabled = true;
      codeEl.replaceWith(errorBtn);
    }
  }
  // Helper to get contrasting text color for a background color
  getContrastColor(hexColor) {
    const hex = hexColor.replace("#", "");
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return luminance > 0.5 ? "#000000" : "#ffffff";
  }
  // Helper to convert hex color to RGBA with opacity
  hexToRGBA(hexColor, opacity) {
    const hex = hexColor.replace("#", "");
    let r, g, b;
    if (hex.length === 3) {
      r = parseInt(hex[0] + hex[0], 16);
      g = parseInt(hex[1] + hex[1], 16);
      b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length === 6) {
      r = parseInt(hex.substr(0, 2), 16);
      g = parseInt(hex.substr(2, 2), 16);
      b = parseInt(hex.substr(4, 2), 16);
    } else {
      return null;
    }
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
  }
  async getProjectColor(projectName) {
    if (!projectName) {
      return null;
    }
    const file = this.app.metadataCache.getFirstLinkpathDest(projectName, "");
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return null;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const frontmatter = match[1];
      const lines = frontmatter.split("\n");
      const colorKeys = ["color", "colour", "lapse-color"];
      for (const key of colorKeys) {
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line.startsWith(`${key}:`)) {
            let value = line.replace(new RegExp(`^${key}:\\s*`), "").trim();
            value = value.replace(/^["']+|["']+$/g, "");
            if (value.match(/^#[0-9A-Fa-f]{3,8}$/) || value.match(/^[a-zA-Z]+$/) || value.match(/^var\(/)) {
              return value;
            }
          }
        }
      }
    } catch (error) {
      console.error("Error reading project color:", error);
    }
    return null;
  }
  async processTimerCodeBlock(source, el, ctx) {
    const filePath = ctx.sourcePath;
    await this.loadEntriesFromFrontmatter(filePath);
    if (!this.timeData.has(filePath)) {
      this.timeData.set(filePath, {
        entries: [],
        totalTimeTracked: 0
      });
    }
    const pageData = this.timeData.get(filePath);
    const activeTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
    const container = el.createDiv({ cls: "lapse-container" });
    const mainLayout = container.createDiv({ cls: "lapse-main-layout" });
    const timerContainer = mainLayout.createDiv({ cls: "lapse-timer-container" });
    const timerDisplay = timerContainer.createDiv({ cls: "lapse-timer-display" });
    timerDisplay.setText("--:--");
    const adjustButtonsContainer = timerContainer.createDiv({ cls: "lapse-adjust-buttons" });
    const adjustBackBtn = adjustButtonsContainer.createEl("button", {
      cls: "lapse-btn-adjust",
      text: `-${this.settings.timeAdjustMinutes}`
    });
    adjustBackBtn.disabled = !activeTimer;
    const adjustForwardBtn = adjustButtonsContainer.createEl("button", {
      cls: "lapse-btn-adjust",
      text: `+${this.settings.timeAdjustMinutes}`
    });
    adjustForwardBtn.disabled = !activeTimer;
    const rightColumn = mainLayout.createDiv({ cls: "lapse-right-column" });
    const topLine = rightColumn.createDiv({ cls: "lapse-top-line" });
    let labelDisplay;
    let labelInput = null;
    if (activeTimer) {
      labelDisplay = topLine.createEl("div", {
        text: activeTimer.label,
        cls: "lapse-label-display-running"
      });
    } else {
      labelInput = topLine.createEl("input", {
        type: "text",
        placeholder: "Timer label...",
        cls: "lapse-label-input"
      });
      labelDisplay = labelInput;
    }
    const playStopBtn = topLine.createEl("button", { cls: "lapse-btn-play-stop" });
    if (activeTimer) {
      (0, import_obsidian.setIcon)(playStopBtn, "square");
      playStopBtn.classList.add("lapse-btn-stop");
    } else {
      (0, import_obsidian.setIcon)(playStopBtn, "play");
      playStopBtn.classList.add("lapse-btn-play");
    }
    const chevronBtn = topLine.createEl("button", { cls: "lapse-btn-chevron" });
    (0, import_obsidian.setIcon)(chevronBtn, "chevron-down");
    const bottomLine = rightColumn.createDiv({ cls: "lapse-bottom-line" });
    const summaryLeft = bottomLine.createDiv({ cls: "lapse-summary-left" });
    const todayLabel = bottomLine.createDiv({ cls: "lapse-today-label" });
    const calculateTotalTime = () => {
      return pageData.entries.reduce((sum, e) => {
        if (e.endTime !== null) {
          return sum + e.duration;
        } else if (e.startTime !== null) {
          return sum + e.duration + (Date.now() - e.startTime);
        }
        return sum;
      }, 0);
    };
    const calculateTodayTotal = () => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayStart = today.getTime();
      return pageData.entries.reduce((sum, e) => {
        if (e.startTime && e.startTime >= todayStart) {
          if (e.endTime !== null) {
            return sum + e.duration;
          } else if (e.startTime !== null) {
            return sum + e.duration + (Date.now() - e.startTime);
          }
        }
        return sum;
      }, 0);
    };
    const updateDisplays = () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      adjustBackBtn.disabled = !currentActiveTimer;
      adjustForwardBtn.disabled = !currentActiveTimer;
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const elapsed = currentActiveTimer.duration + (Date.now() - currentActiveTimer.startTime);
        timerDisplay.setText(this.formatTimeForTimerDisplay(elapsed));
      } else {
        timerDisplay.setText("--:--");
      }
      const entryCount = pageData.entries.length;
      const totalTime = calculateTotalTime();
      summaryLeft.setText(`${entryCount} ${entryCount === 1 ? "entry" : "entries"}, ${this.formatTimeAsHHMMSS(totalTime)}`);
      const todayTotal = calculateTodayTotal();
      todayLabel.setText(`Today: ${this.formatTimeAsHHMMSS(todayTotal)}`);
    };
    updateDisplays();
    let updateInterval = null;
    if (activeTimer) {
      updateInterval = window.setInterval(updateDisplays, 1e3);
    }
    adjustBackBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const adjustMinutes = this.settings.timeAdjustMinutes;
        const adjustMs = adjustMinutes * 60 * 1e3;
        currentActiveTimer.startTime = currentActiveTimer.startTime - adjustMs;
        await this.updateFrontmatter(filePath);
        updateDisplays();
      }
    };
    adjustForwardBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const adjustMinutes = this.settings.timeAdjustMinutes;
        const adjustMs = adjustMinutes * 60 * 1e3;
        currentActiveTimer.startTime = currentActiveTimer.startTime + adjustMs;
        await this.updateFrontmatter(filePath);
        updateDisplays();
      }
    };
    const panel = container.createDiv({ cls: "lapse-panel" });
    panel.style.display = "none";
    const cardsContainer = panel.createDiv({ cls: "lapse-cards-container" });
    this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
    const addButton = panel.createEl("button", {
      text: "+ Add Entry",
      cls: "lapse-btn-add"
    });
    let isPanelOpen = false;
    chevronBtn.onclick = () => {
      isPanelOpen = !isPanelOpen;
      if (isPanelOpen) {
        panel.style.display = "block";
        (0, import_obsidian.setIcon)(chevronBtn, "chevron-up");
      } else {
        panel.style.display = "none";
        (0, import_obsidian.setIcon)(chevronBtn, "chevron-down");
      }
    };
    playStopBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer) {
        if (!currentActiveTimer.isPaused && currentActiveTimer.startTime) {
          currentActiveTimer.duration += Date.now() - currentActiveTimer.startTime;
        }
        currentActiveTimer.endTime = Date.now();
        currentActiveTimer.isPaused = false;
        if (updateInterval) {
          clearInterval(updateInterval);
          updateInterval = null;
        }
        await this.updateFrontmatter(filePath);
        if (labelInput) {
          labelInput.value = "";
        } else if (labelDisplay) {
          labelDisplay.remove();
          labelInput = topLine.createEl("input", {
            type: "text",
            placeholder: "Timer label...",
            cls: "lapse-label-input"
          });
          const playBtn = topLine.querySelector(".lapse-btn-play-stop");
          if (playBtn) {
            topLine.insertBefore(labelInput, playBtn);
          }
          labelDisplay = labelInput;
        }
        (0, import_obsidian.setIcon)(playStopBtn, "play");
        playStopBtn.classList.remove("lapse-btn-stop");
        playStopBtn.classList.add("lapse-btn-play");
        updateDisplays();
        this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      } else {
        let label = "";
        if (labelInput) {
          label = labelInput.value.trim();
        }
        if (!label) {
          label = await this.getDefaultLabel(filePath);
        }
        const newEntry = {
          id: `${filePath}-${Date.now()}-${Math.random()}`,
          label,
          startTime: Date.now(),
          endTime: null,
          duration: 0,
          isPaused: false,
          tags: this.getDefaultTags()
        };
        pageData.entries.push(newEntry);
        if (!updateInterval) {
          updateInterval = window.setInterval(updateDisplays, 1e3);
        }
        await this.addDefaultTagToNote(filePath);
        await this.updateFrontmatter(filePath);
        if (labelInput) {
          labelInput.remove();
          labelDisplay = topLine.createEl("div", {
            text: label,
            // Use the resolved label value
            cls: "lapse-label-display-running"
          });
          const playBtn = topLine.querySelector(".lapse-btn-play-stop");
          if (playBtn) {
            topLine.insertBefore(labelDisplay, playBtn);
          }
          labelInput = null;
        } else if (labelDisplay) {
          labelDisplay.setText(label);
        } else {
          labelDisplay = topLine.createEl("div", {
            text: label,
            cls: "lapse-label-display-running"
          });
          const playBtn = topLine.querySelector(".lapse-btn-play-stop");
          if (playBtn) {
            topLine.insertBefore(labelDisplay, playBtn);
          }
        }
        (0, import_obsidian.setIcon)(playStopBtn, "square");
        playStopBtn.classList.remove("lapse-btn-play");
        playStopBtn.classList.add("lapse-btn-stop");
        updateDisplays();
        this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      }
    };
    addButton.onclick = async () => {
      const newEntry = {
        id: `${filePath}-${Date.now()}-${Math.random()}`,
        label: "New Entry",
        startTime: null,
        endTime: null,
        duration: 0,
        isPaused: false,
        tags: this.getDefaultTags()
      };
      pageData.entries.push(newEntry);
      await this.updateFrontmatter(filePath);
      this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
    };
  }
  async processReportCodeBlock(source, el, ctx) {
    const container = el.createDiv({ cls: "lapse-report-container" });
    const loadingContainer = container.createDiv({ cls: "lapse-report-loading" });
    const loadingText = loadingContainer.createDiv({ cls: "lapse-report-loading-text" });
    loadingText.setText("Loading Lapse Report");
    const spinnerContainer = loadingContainer.createDiv({ cls: "lapse-report-loading-spinner" });
    const spinner = spinnerContainer.createEl("span", { cls: "lapse-spinner-icon" });
    (0, import_obsidian.setIcon)(spinner, "loader-2");
    const query = this.parseQuery(source);
    console.log("Lapse Report Query:", query);
    const { startTime, endTime } = this.getDateRange(query);
    console.log("Date Range:", {
      startTime: new Date(startTime).toISOString(),
      endTime: new Date(endTime).toISOString()
    });
    const matchedEntries = await this.getMatchingEntries(query, startTime, endTime);
    console.log("Matched Entries:", matchedEntries.length);
    const groupedData = this.groupEntries(matchedEntries, query.groupBy || "project");
    console.log("Grouped Data:", groupedData.size, "groups");
    container.empty();
    if (query.display === "summary") {
      await this.renderReportSummary(container, groupedData, query);
    } else if (query.display === "chart") {
      await this.renderReportChartOnly(container, groupedData, query);
    } else {
      await this.renderReportTable(container, groupedData, query);
    }
  }
  async processActiveTimersCodeBlock(source, el, ctx) {
    const container = el.createDiv({ cls: "lapse-active-container" });
    const timeDisplays = /* @__PURE__ */ new Map();
    const updateIntervals = /* @__PURE__ */ new Map();
    const getActiveTimers = async () => {
      const activeTimers = [];
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile) {
        const currentFilePath = currentFile.path;
        await this.loadEntriesFromFrontmatter(currentFilePath);
        const currentPageData = this.timeData.get(currentFilePath);
        if (currentPageData) {
          currentPageData.entries.forEach((entry) => {
            if (entry.startTime && !entry.endTime) {
              activeTimers.push({ filePath: currentFilePath, entry });
            }
          });
        }
      }
      this.timeData.forEach((pageData, filePath) => {
        if (currentFile && filePath === currentFile.path) {
          return;
        }
        pageData.entries.forEach((entry) => {
          if (entry.startTime && !entry.endTime) {
            activeTimers.push({ filePath, entry });
          }
        });
      });
      const markdownFiles = this.app.vault.getMarkdownFiles();
      for (const file of markdownFiles) {
        const filePath = file.path;
        if (this.isFileExcluded(filePath)) {
          continue;
        }
        if (this.timeData.has(filePath)) {
          continue;
        }
        const { entries } = await this.getCachedOrLoadEntries(filePath);
        entries.forEach((entry) => {
          if (entry.startTime && !entry.endTime) {
            activeTimers.push({ filePath, entry });
          }
        });
      }
      return activeTimers;
    };
    const renderActiveTimers = async () => {
      updateIntervals.forEach((intervalId) => window.clearInterval(intervalId));
      updateIntervals.clear();
      timeDisplays.clear();
      container.empty();
      const activeTimers = await getActiveTimers();
      if (activeTimers.length === 0) {
        container.createEl("p", { text: "No active timers", cls: "lapse-active-empty" });
        return;
      }
      for (const { filePath, entry } of activeTimers) {
        const row = container.createDiv({ cls: "lapse-active-row" });
        const elapsed = entry.duration + (entry.isPaused ? 0 : Date.now() - entry.startTime);
        const timeText = this.formatTimeAsHHMMSS(elapsed);
        const timeDisplay = row.createDiv({
          text: timeText,
          cls: "lapse-active-time"
        });
        timeDisplays.set(entry.id, timeDisplay);
        const labelDisplay = row.createDiv({
          text: entry.label,
          cls: "lapse-active-label"
        });
        const actionsContainer = row.createDiv({ cls: "lapse-active-actions" });
        const jumpBtn = actionsContainer.createEl("button", {
          cls: "lapse-active-btn lapse-active-btn-jump",
          attr: { "aria-label": "Jump to note" }
        });
        (0, import_obsidian.setIcon)(jumpBtn, "arrow-right");
        jumpBtn.onclick = async () => {
          await this.app.workspace.openLinkText(filePath, "", true);
        };
        const stopBtn = actionsContainer.createEl("button", {
          cls: "lapse-active-btn lapse-active-btn-stop",
          attr: { "aria-label": "Stop timer" }
        });
        (0, import_obsidian.setIcon)(stopBtn, "square");
        stopBtn.onclick = async (e) => {
          e.stopPropagation();
          const pageData = this.timeData.get(filePath);
          if (pageData) {
            const entryInData = pageData.entries.find((e2) => e2.id === entry.id);
            if (entryInData && entryInData.startTime && !entryInData.endTime) {
              const now = Date.now();
              entryInData.endTime = now;
              entryInData.duration += now - entryInData.startTime;
              entryInData.startTime = null;
              pageData.totalTimeTracked = pageData.entries.reduce((sum, e2) => sum + e2.duration, 0);
              await this.updateFrontmatter(filePath);
              await renderActiveTimers();
            }
          }
        };
        const intervalId = window.setInterval(() => {
          if (entry.startTime && !entry.endTime) {
            const newElapsed = entry.duration + (entry.isPaused ? 0 : Date.now() - entry.startTime);
            const display = timeDisplays.get(entry.id);
            if (display) {
              display.setText(this.formatTimeAsHHMMSS(newElapsed));
            }
          } else {
            window.clearInterval(intervalId);
            updateIntervals.delete(entry.id);
          }
        }, 1e3);
        updateIntervals.set(entry.id, intervalId);
      }
    };
    const checkForTimerChanges = () => {
      const currentActiveTimers = [];
      this.timeData.forEach((pageData, filePath) => {
        pageData.entries.forEach((entry) => {
          if (entry.startTime && !entry.endTime) {
            currentActiveTimers.push({ filePath, entry });
          }
        });
      });
      const activeEntryIds = new Set(currentActiveTimers.map(({ entry }) => entry.id));
      const displayedEntryIds = new Set(timeDisplays.keys());
      const needsFullRefresh = currentActiveTimers.length !== displayedEntryIds.size || ![...displayedEntryIds].every((id) => activeEntryIds.has(id)) || !currentActiveTimers.every(({ entry }) => displayedEntryIds.has(entry.id));
      if (needsFullRefresh) {
        renderActiveTimers();
      }
    };
    await renderActiveTimers();
    const checkInterval = window.setInterval(() => {
      checkForTimerChanges();
    }, 5e3);
    const refreshInterval = window.setInterval(async () => {
      await renderActiveTimers();
    }, 3e4);
    ctx.addChild({
      unload: () => {
        window.clearInterval(checkInterval);
        window.clearInterval(refreshInterval);
        updateIntervals.forEach((intervalId) => window.clearInterval(intervalId));
      }
    });
  }
  parseQuery(source) {
    const query = {
      display: "table",
      groupBy: "project",
      chart: "none"
    };
    const lines = source.split("\n").map((l) => l.trim()).filter((l) => l && !l.startsWith("#"));
    for (const line of lines) {
      const [key, ...valueParts] = line.split(":").map((s) => s.trim());
      let value = valueParts.join(":").trim();
      if (!value)
        continue;
      value = this.cleanQueryValue(value);
      switch (key.toLowerCase()) {
        case "project":
          query.project = value;
          break;
        case "tag":
          query.tag = value;
          break;
        case "note":
          query.note = value;
          break;
        case "from":
          query.from = value;
          break;
        case "to":
          query.to = value;
          break;
        case "period":
          const periodValue = value.toLowerCase();
          if (["today", "thisweek", "thismonth", "lastweek", "lastmonth"].includes(periodValue)) {
            if (periodValue === "thisweek")
              query.period = "thisWeek";
            else if (periodValue === "thismonth")
              query.period = "thisMonth";
            else if (periodValue === "lastweek")
              query.period = "lastWeek";
            else if (periodValue === "lastmonth")
              query.period = "lastMonth";
            else
              query.period = periodValue;
          }
          break;
        case "group-by":
          if (["project", "date", "tag", "note"].includes(value.toLowerCase())) {
            query.groupBy = value.toLowerCase();
          }
          break;
        case "display":
          if (["table", "summary", "chart"].includes(value.toLowerCase())) {
            query.display = value.toLowerCase();
          }
          break;
        case "chart":
          if (["bar", "pie", "none"].includes(value.toLowerCase())) {
            query.chart = value.toLowerCase();
          }
          break;
      }
    }
    return query;
  }
  cleanQueryValue(value) {
    value = value.replace(/\[\[/g, "").replace(/\]\]/g, "");
    value = value.replace(/^["']|["']$/g, "");
    value = value.replace(/^#/, "");
    return value.trim();
  }
  getDateRange(query) {
    let startTime;
    let endTime;
    if (query.period) {
      const now = new Date();
      let startDate;
      let endDate = new Date(now);
      if (query.period === "today") {
        startDate = new Date(now);
        startDate.setHours(0, 0, 0, 0);
      } else if (query.period === "thisWeek") {
        startDate = new Date(now);
        const dayOfWeek = startDate.getDay();
        const daysFromFirstDay = (dayOfWeek - this.settings.firstDayOfWeek + 7) % 7;
        startDate.setDate(startDate.getDate() - daysFromFirstDay);
        startDate.setHours(0, 0, 0, 0);
      } else if (query.period === "thisMonth") {
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        startDate.setHours(0, 0, 0, 0);
      } else if (query.period === "lastWeek") {
        const firstDayOfWeek = this.settings.firstDayOfWeek;
        const today = new Date(now);
        const dayOfWeek = today.getDay();
        const daysFromFirstDay = (dayOfWeek - firstDayOfWeek + 7) % 7;
        startDate = new Date(today);
        startDate.setDate(today.getDate() - daysFromFirstDay - 7);
        startDate.setHours(0, 0, 0, 0);
        endDate = new Date(startDate);
        endDate.setDate(startDate.getDate() + 6);
        endDate.setHours(23, 59, 59, 999);
      } else {
        const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        startDate = new Date(lastMonth);
        startDate.setHours(0, 0, 0, 0);
        endDate = new Date(now.getFullYear(), now.getMonth(), 0);
        endDate.setHours(23, 59, 59, 999);
      }
      startTime = startDate.getTime();
      endTime = endDate.getTime();
    } else {
      if (query.from) {
        const startDate = new Date(query.from);
        startDate.setHours(0, 0, 0, 0);
        startTime = startDate.getTime();
      } else {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        startTime = today.getTime();
      }
      if (query.to) {
        const endDate = new Date(query.to);
        endDate.setHours(23, 59, 59, 999);
        endTime = endDate.getTime();
      } else {
        const today = new Date();
        today.setHours(23, 59, 59, 999);
        endTime = today.getTime();
      }
    }
    return { startTime, endTime };
  }
  /**
   * Get the default note name (without timestamp) for a given file path
   */
  getDefaultNoteName(filePath) {
    var _a;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file && file instanceof import_obsidian.TFile) {
      return this.removeTimestampFromFileName(file.basename);
    }
    const fileName = ((_a = filePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || filePath;
    return this.removeTimestampFromFileName(fileName);
  }
  /**
   * Get date range for a time period
   */
  getDateRangeForPeriod(period) {
    const now = new Date();
    let startDate;
    let endDate = new Date(now);
    endDate.setHours(23, 59, 59, 999);
    if (period === "today") {
      startDate = new Date(now);
      startDate.setHours(0, 0, 0, 0);
    } else if (period === "thisWeek") {
      startDate = new Date(now);
      const dayOfWeek = startDate.getDay();
      const daysFromFirstDay = (dayOfWeek - this.settings.firstDayOfWeek + 7) % 7;
      startDate.setDate(startDate.getDate() - daysFromFirstDay);
      startDate.setHours(0, 0, 0, 0);
    } else if (period === "thisMonth") {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      startDate.setHours(0, 0, 0, 0);
    } else if (period === "lastWeek") {
      const firstDayOfWeek = this.settings.firstDayOfWeek;
      const today = new Date(now);
      const dayOfWeek = today.getDay();
      const daysFromFirstDay = (dayOfWeek - firstDayOfWeek + 7) % 7;
      startDate = new Date(today);
      startDate.setDate(today.getDate() - daysFromFirstDay - 7);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
    } else {
      const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      startDate = new Date(lastMonth);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(now.getFullYear(), now.getMonth(), 0);
      endDate.setHours(23, 59, 59, 999);
    }
    return { startTime: startDate.getTime(), endTime: endDate.getTime() };
  }
  /**
   * Calculate duration for a template button based on settings
   * Always aggregates across multiple notes based on the duration type
   */
  async getTemplateButtonDuration(templateName, templateProject) {
    if (!this.settings.showDurationOnNoteButtons) {
      return 0;
    }
    const { startTime, endTime } = this.getDateRangeForPeriod(this.settings.noteButtonTimePeriod);
    let totalDuration = 0;
    const markdownFiles = this.app.vault.getMarkdownFiles();
    if (this.settings.noteButtonDurationType === "project") {
      if (!templateProject) {
        return 0;
      }
      for (const file of markdownFiles) {
        const currentFilePath = file.path;
        if (this.isFileExcluded(currentFilePath)) {
          continue;
        }
        const currentProject = await this.getProjectFromFrontmatter(currentFilePath);
        if (currentProject === templateProject) {
          const { entries } = await this.getCachedOrLoadEntries(currentFilePath);
          if (entries.length > 0) {
            for (const entry of entries) {
              if (entry.startTime) {
                const entryStart = entry.startTime;
                const entryEnd = entry.endTime || Date.now();
                if (entryStart <= endTime && entryEnd >= startTime) {
                  const periodStart = Math.max(entryStart, startTime);
                  const periodEnd = Math.min(entryEnd, endTime);
                  if (entry.endTime) {
                    const entryTotalDuration = entryEnd - entryStart;
                    if (entryTotalDuration > 0) {
                      const periodDuration = periodEnd - periodStart;
                      const scaledDuration = entry.duration * (periodDuration / entryTotalDuration);
                      totalDuration += scaledDuration;
                    }
                  } else {
                    totalDuration += periodEnd - periodStart;
                  }
                }
              }
            }
          }
        }
      }
    } else {
      for (const file of markdownFiles) {
        const currentFilePath = file.path;
        if (this.isFileExcluded(currentFilePath)) {
          continue;
        }
        const currentBaseName = this.getDefaultNoteName(currentFilePath);
        if (currentBaseName === templateName) {
          const { entries } = await this.getCachedOrLoadEntries(currentFilePath);
          for (const entry of entries) {
            if (entry.startTime) {
              const entryStart = entry.startTime;
              const entryEnd = entry.endTime || Date.now();
              if (entryStart <= endTime && entryEnd >= startTime) {
                const periodStart = Math.max(entryStart, startTime);
                const periodEnd = Math.min(entryEnd, endTime);
                if (entry.endTime) {
                  const entryTotalDuration = entryEnd - entryStart;
                  if (entryTotalDuration > 0) {
                    const periodDuration = periodEnd - periodStart;
                    const scaledDuration = entry.duration * (periodDuration / entryTotalDuration);
                    totalDuration += scaledDuration;
                  }
                } else {
                  totalDuration += periodEnd - periodStart;
                }
              }
            }
          }
        }
      }
    }
    return totalDuration;
  }
  /**
   * Calculate duration for a note based on settings
   * Always aggregates across multiple notes based on the duration type
   */
  async getNoteButtonDuration(filePath) {
    if (!this.settings.showDurationOnNoteButtons) {
      return 0;
    }
    const { startTime, endTime } = this.getDateRangeForPeriod(this.settings.noteButtonTimePeriod);
    let totalDuration = 0;
    const markdownFiles = this.app.vault.getMarkdownFiles();
    if (this.settings.noteButtonDurationType === "project") {
      const project = await this.getProjectFromFrontmatter(filePath);
      if (!project) {
        return 0;
      }
      for (const file of markdownFiles) {
        const currentFilePath = file.path;
        if (this.isFileExcluded(currentFilePath)) {
          continue;
        }
        const currentProject = await this.getProjectFromFrontmatter(currentFilePath);
        if (currentProject === project) {
          const { entries } = await this.getCachedOrLoadEntries(currentFilePath);
          if (entries.length > 0) {
            for (const entry of entries) {
              if (entry.startTime) {
                const entryStart = entry.startTime;
                const entryEnd = entry.endTime || Date.now();
                if (entryStart <= endTime && entryEnd >= startTime) {
                  const periodStart = Math.max(entryStart, startTime);
                  const periodEnd = Math.min(entryEnd, endTime);
                  if (entry.endTime) {
                    const entryTotalDuration = entryEnd - entryStart;
                    if (entryTotalDuration > 0) {
                      const periodDuration = periodEnd - periodStart;
                      const scaledDuration = entry.duration * (periodDuration / entryTotalDuration);
                      totalDuration += scaledDuration;
                    }
                  } else {
                    totalDuration += periodEnd - periodStart;
                  }
                }
              }
            }
          }
        }
      }
    } else {
      const baseNoteName = this.getDefaultNoteName(filePath);
      for (const file of markdownFiles) {
        const currentFilePath = file.path;
        if (this.isFileExcluded(currentFilePath)) {
          continue;
        }
        const currentBaseName = this.getDefaultNoteName(currentFilePath);
        if (currentBaseName === baseNoteName) {
          const { entries } = await this.getCachedOrLoadEntries(currentFilePath);
          for (const entry of entries) {
            if (entry.startTime) {
              const entryStart = entry.startTime;
              const entryEnd = entry.endTime || Date.now();
              if (entryStart <= endTime && entryEnd >= startTime) {
                const periodStart = Math.max(entryStart, startTime);
                const periodEnd = Math.min(entryEnd, endTime);
                if (entry.endTime) {
                  const entryTotalDuration = entryEnd - entryStart;
                  if (entryTotalDuration > 0) {
                    const periodDuration = periodEnd - periodStart;
                    const scaledDuration = entry.duration * (periodDuration / entryTotalDuration);
                    totalDuration += scaledDuration;
                  }
                } else {
                  totalDuration += periodEnd - periodStart;
                }
              }
            }
          }
        }
      }
    }
    return totalDuration;
  }
  async getMatchingEntries(query, startTime, endTime) {
    const matchedEntries = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (this.isFileExcluded(filePath)) {
        continue;
      }
      let noteName = file.basename;
      if (this.settings.hideTimestampsInViews) {
        noteName = this.removeTimestampFromFileName(noteName);
      }
      if (query.note && !noteName.toLowerCase().includes(query.note.toLowerCase())) {
        continue;
      }
      const { entries: fileEntries, project } = await this.getCachedOrLoadEntries(filePath);
      if (query.project) {
        if (!project) {
          continue;
        }
        if (!project.toLowerCase().includes(query.project.toLowerCase())) {
          continue;
        }
      }
      const noteTags = await this.getNoteTags(filePath);
      for (const entry of fileEntries) {
        if (!entry.startTime || entry.startTime < startTime || entry.startTime > endTime) {
          continue;
        }
        if (query.tag) {
          const tagLower = query.tag.toLowerCase();
          const hasNoteTag = noteTags.some((t) => t.toLowerCase().includes(tagLower));
          const hasEntryTag = entry.tags && entry.tags.some((t) => t.toLowerCase().includes(tagLower));
          if (!hasNoteTag && !hasEntryTag) {
            continue;
          }
        }
        if (entry.endTime || entry.startTime && !entry.endTime) {
          matchedEntries.push({
            filePath,
            entry,
            project,
            noteName,
            noteTags
          });
        }
      }
    }
    return matchedEntries;
  }
  async getNoteTags(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return [];
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return [];
      }
      const frontmatter = match[1];
      const tagsMatch = frontmatter.match(/tags?:\s*\[?([^\]]+)\]?/);
      if (tagsMatch) {
        return tagsMatch[1].split(",").map((t) => t.trim().replace(/['"#]/g, "")).filter((t) => t);
      }
      return [];
    } catch (error) {
      return [];
    }
  }
  groupEntries(entries, groupBy) {
    const grouped = /* @__PURE__ */ new Map();
    for (const item of entries) {
      let groupKey;
      if (groupBy === "project") {
        groupKey = item.project ? item.project.split("/").pop() || "No Project" : "No Project";
      } else if (groupBy === "date") {
        const date = new Date(item.entry.startTime);
        groupKey = date.toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" });
      } else if (groupBy === "note") {
        groupKey = item.noteName || "Unknown Note";
      } else {
        groupKey = item.entry.tags && item.entry.tags.length > 0 ? `#${item.entry.tags[0]}` : "No Tag";
      }
      if (!grouped.has(groupKey)) {
        grouped.set(groupKey, {
          totalTime: 0,
          entryCount: 0,
          entries: []
        });
      }
      const group = grouped.get(groupKey);
      const entryDuration = item.entry.endTime ? item.entry.duration : item.entry.duration + (Date.now() - item.entry.startTime);
      group.totalTime += entryDuration;
      group.entryCount++;
      group.entries.push(item);
    }
    return grouped;
  }
  async renderReportSummary(container, groupedData, query) {
    container.createEl("h4", { text: "Summary", cls: "lapse-report-title" });
    let totalTime = 0;
    groupedData.forEach((group) => {
      totalTime += group.totalTime;
    });
    const summaryDiv = container.createDiv({ cls: "lapse-report-summary-total" });
    summaryDiv.createEl("span", { text: "Total Time: ", cls: "lapse-report-summary-label" });
    summaryDiv.createEl("span", { text: this.formatTimeAsHHMMSS(totalTime), cls: "lapse-report-summary-value" });
    const breakdownDiv = container.createDiv({ cls: "lapse-report-breakdown" });
    const sortedGroups = Array.from(groupedData.entries()).sort((a, b) => b[1].totalTime - a[1].totalTime);
    const groupBy = query.groupBy || "project";
    for (const [groupName, group] of sortedGroups) {
      const groupDiv = breakdownDiv.createDiv({ cls: "lapse-report-breakdown-item" });
      const nameSpan = groupDiv.createEl("span", { text: groupName, cls: "lapse-report-breakdown-name" });
      if (groupBy === "project") {
        const projectColor = await this.getProjectColor(groupName);
        if (projectColor) {
          nameSpan.style.color = projectColor;
        }
      }
      groupDiv.createEl("span", { text: this.formatTimeAsHHMMSS(group.totalTime), cls: "lapse-report-breakdown-time" });
    }
    if (query.chart && query.chart !== "none" && sortedGroups.length > 0) {
      const chartContainer = container.createDiv({ cls: "lapse-report-chart-container" });
      const chartData = sortedGroups.map(([group, data]) => ({
        group,
        totalTime: data.totalTime
      }));
      await this.renderReportChart(chartContainer, chartData, totalTime, query.chart, query.groupBy);
    }
  }
  async renderReportTable(container, groupedData, query) {
    container.createEl("h4", { text: "Report", cls: "lapse-report-title" });
    let totalTime = 0;
    groupedData.forEach((group) => {
      totalTime += group.totalTime;
    });
    const summaryDiv = container.createDiv({ cls: "lapse-report-summary-total" });
    summaryDiv.createEl("span", { text: "Total: ", cls: "lapse-report-summary-label" });
    summaryDiv.createEl("span", { text: this.formatTimeAsHHMMSS(totalTime), cls: "lapse-report-summary-value" });
    const tableContainer = container.createDiv({ cls: "lapse-report-table-container" });
    const table = tableContainer.createEl("table", { cls: "lapse-reports-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    const groupBy = query.groupBy || "project";
    if (groupBy === "note") {
      headerRow.createEl("th", { text: "Note" });
      headerRow.createEl("th", { text: "Label" });
      headerRow.createEl("th", { text: "Time" });
    } else {
      headerRow.createEl("th", { text: this.getGroupByLabel(groupBy) });
      headerRow.createEl("th", { text: "Entries" });
      headerRow.createEl("th", { text: "Time" });
    }
    const tbody = table.createEl("tbody");
    const sortedGroups = Array.from(groupedData.entries()).sort((a, b) => b[1].totalTime - a[1].totalTime);
    if (groupBy === "note") {
      for (const [groupName, group] of sortedGroups) {
        const sortedEntries = [...group.entries].sort((a, b) => (b.entry.startTime || 0) - (a.entry.startTime || 0));
        for (const entryItem of sortedEntries) {
          const row = tbody.createEl("tr");
          row.createEl("td", { text: groupName });
          row.createEl("td", { text: entryItem.entry.label });
          const entryDuration = entryItem.entry.endTime ? entryItem.entry.duration : entryItem.entry.duration + (Date.now() - (entryItem.entry.startTime || 0));
          row.createEl("td", { text: this.formatTimeAsHHMMSS(entryDuration) });
        }
      }
    } else {
      for (const [groupName, group] of sortedGroups) {
        const row = tbody.createEl("tr");
        const groupCell = row.createEl("td");
        if (groupBy === "project") {
          const projectColor = await this.getProjectColor(groupName);
          const groupSpan = groupCell.createSpan({ text: groupName });
          if (projectColor) {
            groupSpan.style.color = projectColor;
          }
        } else {
          groupCell.setText(groupName);
        }
        row.createEl("td", { text: group.entryCount.toString() });
        row.createEl("td", { text: this.formatTimeAsHHMMSS(group.totalTime) });
      }
    }
    if (query.chart && query.chart !== "none" && sortedGroups.length > 0) {
      const chartContainer = container.createDiv({ cls: "lapse-report-chart-container" });
      const chartData = sortedGroups.map(([group, data]) => ({
        group,
        totalTime: data.totalTime
      }));
      await this.renderReportChart(chartContainer, chartData, totalTime, query.chart, query.groupBy);
    }
  }
  getGroupByLabel(groupBy) {
    switch (groupBy) {
      case "project":
        return "Project";
      case "date":
        return "Date";
      case "tag":
        return "Tag";
      case "note":
        return "Note";
      default:
        return "Group";
    }
  }
  async renderReportChartOnly(container, groupedData, query) {
    let totalTime = 0;
    groupedData.forEach((group) => {
      totalTime += group.totalTime;
    });
    const sortedGroups = Array.from(groupedData.entries()).sort((a, b) => b[1].totalTime - a[1].totalTime);
    if (query.chart && query.chart !== "none" && sortedGroups.length > 0) {
      const chartContainer = container.createDiv({ cls: "lapse-report-chart-container" });
      const chartData = sortedGroups.map(([group, data]) => ({
        group,
        totalTime: data.totalTime
      }));
      await this.renderReportChart(chartContainer, chartData, totalTime, query.chart, query.groupBy);
    } else {
      container.createEl("p", {
        text: "Please specify a chart type (chart: pie or chart: bar)",
        cls: "lapse-report-error"
      });
    }
  }
  async renderReportChart(container, data, totalTime, chartType, groupBy) {
    if (chartType === "pie") {
      await this.renderPieChart(container, data, totalTime, groupBy);
    } else {
      await this.renderBarChart(container, data, totalTime, groupBy);
    }
  }
  async renderPieChart(container, data, totalTime, groupBy) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "lapse-report-pie-chart");
    svg.setAttribute("width", "300");
    svg.setAttribute("height", "300");
    svg.setAttribute("viewBox", "0 0 300 300");
    container.appendChild(svg);
    const defaultColors = [
      "#4A90E2",
      "#50C878",
      "#FF6B6B",
      "#FFD93D",
      "#9B59B6",
      "#E67E22",
      "#1ABC9C",
      "#E74C3C"
    ];
    const isGroupingByProject = groupBy === "project";
    const dataWithColors = await Promise.all(data.map(async ({ group, totalTime: time }, index) => {
      let color = defaultColors[index % defaultColors.length];
      if (isGroupingByProject) {
        const projectColor = await this.getProjectColor(group);
        if (projectColor) {
          color = projectColor;
        }
      }
      return { group, totalTime: time, color };
    }));
    const centerX = 150;
    const centerY = 150;
    const radius = 100;
    let currentAngle = -Math.PI / 2;
    dataWithColors.forEach(({ group, totalTime: time, color }) => {
      const percentage = time / totalTime;
      const angle = percentage * 2 * Math.PI;
      const startAngle = currentAngle;
      const endAngle = currentAngle + angle;
      const x1 = centerX + radius * Math.cos(startAngle);
      const y1 = centerY + radius * Math.sin(startAngle);
      const x2 = centerX + radius * Math.cos(endAngle);
      const y2 = centerY + radius * Math.sin(endAngle);
      const largeArc = angle > Math.PI ? 1 : 0;
      const pathData = [
        `M ${centerX} ${centerY}`,
        `L ${x1} ${y1}`,
        `A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`,
        "Z"
      ].join(" ");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", pathData);
      path.setAttribute("fill", color);
      path.setAttribute("stroke", "var(--background-primary)");
      path.setAttribute("stroke-width", "2");
      svg.appendChild(path);
      currentAngle += angle;
    });
    const legend = container.createDiv({ cls: "lapse-report-legend" });
    dataWithColors.forEach(({ group, totalTime: time, color }) => {
      const legendItem = legend.createDiv({ cls: "lapse-report-legend-item" });
      const colorBox = legendItem.createDiv({ cls: "lapse-report-legend-color" });
      colorBox.style.backgroundColor = color;
      const label = legendItem.createDiv({ cls: "lapse-report-legend-label" });
      const nameSpan = label.createSpan({ text: group });
      if (isGroupingByProject) {
        nameSpan.style.color = color;
      }
      label.createSpan({ text: this.formatTimeAsHHMMSS(time), cls: "lapse-report-legend-time" });
    });
  }
  async renderBarChart(container, data, totalTime, groupBy) {
    const viewBoxWidth = 800;
    const chartHeight = 250;
    const labelHeight = 80;
    const totalHeight = chartHeight + labelHeight;
    const padding = 40;
    const chartAreaWidth = viewBoxWidth - padding * 2;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "lapse-report-bar-chart");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "300");
    svg.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${totalHeight}`);
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    container.appendChild(svg);
    const defaultColors = [
      "#4A90E2",
      "#50C878",
      "#FF6B6B",
      "#FFD93D",
      "#9B59B6",
      "#E67E22",
      "#1ABC9C",
      "#E74C3C"
    ];
    const isGroupingByProject = groupBy === "project";
    const dataWithColors = await Promise.all(data.map(async (item, index) => {
      let color = defaultColors[index % defaultColors.length];
      if (isGroupingByProject) {
        const projectColor = await this.getProjectColor(item.group);
        if (projectColor) {
          color = projectColor;
        }
      }
      return { ...item, color };
    }));
    const maxTime = Math.max(...dataWithColors.map((d) => d.totalTime));
    const barCount = dataWithColors.length;
    const barWidth = chartAreaWidth / barCount;
    const maxBarHeight = chartHeight - padding * 2;
    dataWithColors.forEach((item, index) => {
      const barHeight = maxTime > 0 ? item.totalTime / maxTime * maxBarHeight : 0;
      const x = padding + index * barWidth;
      const y = chartHeight - padding - barHeight;
      const barGap = barWidth * 0.1;
      const actualBarWidth = barWidth - barGap;
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("x", (x + barGap / 2).toString());
      rect.setAttribute("y", y.toString());
      rect.setAttribute("width", actualBarWidth.toString());
      rect.setAttribute("height", barHeight.toString());
      rect.setAttribute("fill", item.color);
      rect.setAttribute("rx", "4");
      svg.appendChild(rect);
      const labelY = chartHeight + 10;
      const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
      foreignObject.setAttribute("x", (x + barGap / 2).toString());
      foreignObject.setAttribute("y", labelY.toString());
      foreignObject.setAttribute("width", actualBarWidth.toString());
      foreignObject.setAttribute("height", labelHeight.toString());
      const labelDiv = document.createElement("div");
      labelDiv.setAttribute("class", "lapse-chart-label");
      labelDiv.style.width = "100%";
      labelDiv.style.height = "100%";
      labelDiv.style.display = "flex";
      labelDiv.style.alignItems = "flex-start";
      labelDiv.style.justifyContent = "center";
      labelDiv.style.fontSize = barCount > 15 ? "9px" : barCount > 10 ? "10px" : "11px";
      labelDiv.style.color = isGroupingByProject ? item.color : "var(--text-muted)";
      labelDiv.style.textAlign = "center";
      labelDiv.style.wordWrap = "break-word";
      labelDiv.style.overflowWrap = "break-word";
      labelDiv.style.lineHeight = "1.2";
      labelDiv.style.padding = "0 2px";
      if (barCount > 10) {
        labelDiv.style.writingMode = "vertical-rl";
        labelDiv.style.textOrientation = "mixed";
        labelDiv.style.transform = "rotate(180deg)";
        labelDiv.style.alignItems = "center";
      }
      labelDiv.textContent = item.group;
      foreignObject.appendChild(labelDiv);
      svg.appendChild(foreignObject);
    });
  }
  renderEntryCards(cardsContainer, entries, filePath, labelDisplay, labelInput) {
    cardsContainer.empty();
    entries.forEach((entry) => {
      const card = cardsContainer.createDiv({ cls: "lapse-entry-card" });
      const topLine = card.createDiv({ cls: "lapse-card-top-line" });
      const labelDiv = topLine.createDiv({ cls: "lapse-card-label" });
      labelDiv.setText(entry.label);
      const actionsDiv = topLine.createDiv({ cls: "lapse-card-actions" });
      const editBtn = actionsDiv.createEl("button", { cls: "lapse-card-btn-edit" });
      const deleteBtn = actionsDiv.createEl("button", { cls: "lapse-card-btn-delete" });
      (0, import_obsidian.setIcon)(editBtn, "pencil");
      (0, import_obsidian.setIcon)(deleteBtn, "trash");
      const detailsLine = card.createDiv({ cls: "lapse-card-details" });
      const startText = entry.startTime ? new Date(entry.startTime).toLocaleString("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric",
        hour: "numeric",
        minute: "2-digit"
      }) : "--";
      const endText = entry.endTime ? new Date(entry.endTime).toLocaleString("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric",
        hour: "numeric",
        minute: "2-digit"
      }) : "--";
      detailsLine.createSpan({ text: `Start: ${startText}`, cls: "lapse-card-detail" });
      detailsLine.createSpan({ text: `End: ${endText}`, cls: "lapse-card-detail" });
      const bottomLine = card.createDiv({ cls: "lapse-card-bottom-line" });
      const durationText = this.formatTimeAsHHMMSS(entry.duration);
      bottomLine.createSpan({ text: `Duration: ${durationText}`, cls: "lapse-card-detail" });
      if (entry.tags && entry.tags.length > 0) {
        const tagsContainer = bottomLine.createDiv({ cls: "lapse-card-tags-inline" });
        entry.tags.forEach((tag) => {
          const tagEl = tagsContainer.createSpan({ text: `#${tag}`, cls: "lapse-card-tag" });
        });
      }
      editBtn.onclick = async () => {
        await this.showEditModal(entry, filePath, labelDisplay, labelInput, () => {
          const pageData = this.timeData.get(filePath);
          if (pageData) {
            this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
          }
        });
      };
      deleteBtn.onclick = async () => {
        const confirmed = await this.showDeleteConfirmation(entry.label);
        if (confirmed) {
          const pageData = this.timeData.get(filePath);
          if (pageData) {
            pageData.entries = pageData.entries.filter((e) => e.id !== entry.id);
            await this.updateFrontmatter(filePath);
            this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
          }
        }
      };
    });
  }
  async showEditModal(entry, filePath, labelDisplay, labelInputParam, onSave) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Edit Entry");
    const content = modal.contentEl;
    content.empty();
    const labelContainer = content.createDiv({ cls: "lapse-modal-field" });
    labelContainer.createEl("label", { text: "Label", attr: { for: "lapse-edit-label" } });
    const labelInput = labelContainer.createEl("input", {
      type: "text",
      value: entry.label,
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-label" }
    });
    const startContainer = content.createDiv({ cls: "lapse-modal-field" });
    startContainer.createEl("label", { text: "Start Time", attr: { for: "lapse-edit-start" } });
    const startInput = startContainer.createEl("input", {
      type: "datetime-local",
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-start" }
    });
    if (entry.startTime) {
      startInput.value = this.formatDateTimeLocal(new Date(entry.startTime));
    }
    const endContainer = content.createDiv({ cls: "lapse-modal-field" });
    endContainer.createEl("label", { text: "End Time", attr: { for: "lapse-edit-end" } });
    const endInput = endContainer.createEl("input", {
      type: "datetime-local",
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-end" }
    });
    if (entry.endTime) {
      endInput.value = this.formatDateTimeLocal(new Date(entry.endTime));
    }
    const durationContainer = content.createDiv({ cls: "lapse-modal-field" });
    durationContainer.createEl("label", { text: "Duration", attr: { for: "lapse-edit-duration" } });
    const durationInput = durationContainer.createEl("input", {
      type: "text",
      value: this.formatTimeAsHHMMSS(entry.duration),
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-duration", readonly: "true" }
    });
    durationInput.readOnly = true;
    const tagsContainer = content.createDiv({ cls: "lapse-modal-field" });
    tagsContainer.createEl("label", { text: "Tags (comma-separated, without #)", attr: { for: "lapse-edit-tags" } });
    const tagsInput = tagsContainer.createEl("input", {
      type: "text",
      value: (entry.tags || []).join(", "),
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-tags", placeholder: "tag1, tag2, tag3" }
    });
    const buttonContainer = content.createDiv({ cls: "lapse-modal-buttons" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    const updateDuration = () => {
      const start = startInput.value ? new Date(startInput.value).getTime() : null;
      const end = endInput.value ? new Date(endInput.value).getTime() : null;
      if (start && end) {
        const duration = end - start;
        durationInput.value = this.formatTimeAsHHMMSS(duration);
      } else if (entry.startTime && !entry.endTime) {
        durationInput.value = this.formatTimeAsHHMMSS(entry.duration);
      } else {
        durationInput.value = this.formatTimeAsHHMMSS(entry.duration);
      }
    };
    startInput.addEventListener("change", updateDuration);
    endInput.addEventListener("change", updateDuration);
    saveBtn.onclick = async () => {
      entry.label = labelInput.value;
      if (startInput.value) {
        entry.startTime = new Date(startInput.value).getTime();
      } else {
        entry.startTime = null;
      }
      if (endInput.value) {
        entry.endTime = new Date(endInput.value).getTime();
      } else {
        entry.endTime = null;
      }
      const tagsStr = tagsInput.value.trim();
      if (tagsStr) {
        entry.tags = tagsStr.split(",").map((t) => {
          t = t.trim();
          return t.startsWith("#") ? t.substring(1) : t;
        }).filter((t) => t);
      } else {
        entry.tags = [];
      }
      if (entry.startTime && entry.endTime) {
        entry.duration = entry.endTime - entry.startTime;
      } else if (entry.startTime && !entry.endTime) {
      }
      const isActiveTimer = entry.startTime !== null && entry.endTime === null;
      if (isActiveTimer && labelDisplay) {
        if (labelInputParam) {
          labelInputParam.value = entry.label;
        } else {
          labelDisplay.setText(entry.label);
        }
      }
      await this.updateFrontmatter(filePath);
      modal.close();
      if (onSave) {
        onSave();
      }
    };
    cancelBtn.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  async showDeleteConfirmation(entryLabel) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Delete Entry");
      const content = modal.contentEl;
      content.empty();
      content.createEl("p", { text: `Are you sure you want to delete "${entryLabel}"?` });
      const buttonContainer = content.createDiv({ cls: "lapse-modal-buttons" });
      const deleteBtn = buttonContainer.createEl("button", { text: "Delete", cls: "mod-warning" });
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      deleteBtn.onclick = () => {
        modal.close();
        resolve(true);
      };
      cancelBtn.onclick = () => {
        modal.close();
        resolve(false);
      };
      modal.open();
    });
  }
  formatDateTimeLocal(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }
  formatTimeAsHHMMSS(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1e3);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor(totalSeconds % 3600 / 60);
    const seconds = totalSeconds % 60;
    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }
  formatTimeForButton(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1e3);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor(totalSeconds % 3600 / 60);
    const seconds = totalSeconds % 60;
    if (hours > 0) {
      return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    } else {
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    }
  }
  formatTimeForTimerDisplay(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1e3);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor(totalSeconds % 3600 / 60);
    const seconds = totalSeconds % 60;
    if (hours > 0) {
      return `${hours}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    } else {
      return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    }
  }
  async updateFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    const pageData = this.timeData.get(filePath);
    if (!pageData)
      return;
    const content = await this.app.vault.read(file);
    const startedEntries = pageData.entries.filter((e) => e.startTime !== null);
    const startTime = startedEntries.length > 0 ? Math.min(...startedEntries.map((e) => e.startTime)) : null;
    const completedEntries = pageData.entries.filter((e) => e.endTime !== null);
    const endTime = completedEntries.length > 0 ? Math.max(...completedEntries.map((e) => e.endTime)) : null;
    const entries = pageData.entries.map((entry) => ({
      label: entry.label,
      start: entry.startTime ? new Date(entry.startTime).toISOString() : null,
      end: entry.endTime ? new Date(entry.endTime).toISOString() : null,
      duration: Math.floor(entry.duration / 1e3),
      tags: entry.tags || []
    }));
    const totalTimeTracked = pageData.entries.filter((e) => e.endTime !== null).reduce((sum, e) => sum + e.duration, 0);
    const totalTimeFormatted = this.formatTimeAsHHMMSS(totalTimeTracked);
    const startTimeKey = this.settings.startTimeKey;
    const endTimeKey = this.settings.endTimeKey;
    const entriesKey = this.settings.entriesKey;
    const totalTimeKey = this.settings.totalTimeKey;
    let lapseFrontmatter = "";
    if (startTime !== null) {
      lapseFrontmatter += `${startTimeKey}: ${new Date(startTime).toISOString()}
`;
    }
    if (endTime !== null) {
      lapseFrontmatter += `${endTimeKey}: ${new Date(endTime).toISOString()}
`;
    }
    if (entries.length > 0) {
      lapseFrontmatter += `${entriesKey}:
`;
      entries.forEach((entry) => {
        const escapedLabel = entry.label.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        lapseFrontmatter += `  - label: "${escapedLabel}"
`;
        if (entry.start) {
          lapseFrontmatter += `    start: ${entry.start}
`;
        }
        if (entry.end) {
          lapseFrontmatter += `    end: ${entry.end}
`;
        }
        lapseFrontmatter += `    duration: ${entry.duration}
`;
        if (entry.tags && entry.tags.length > 0) {
          lapseFrontmatter += `    tags: [${entry.tags.map((t) => `"${t}"`).join(", ")}]
`;
        }
      });
    } else {
      lapseFrontmatter += `${entriesKey}: []
`;
    }
    lapseFrontmatter += `${totalTimeKey}: "${totalTimeFormatted}"
`;
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      const existingFM = frontmatterMatch[1];
      const lines = existingFM.split("\n");
      let inLapseArray = false;
      const filteredLines = lines.filter((line) => {
        const trimmed = line.trim();
        if (trimmed.startsWith(`${entriesKey}:`)) {
          inLapseArray = true;
          return false;
        }
        if (inLapseArray) {
          if (line.match(/^\s+(-|\w+:)/)) {
            return false;
          }
          inLapseArray = false;
        }
        if (trimmed.startsWith(`${startTimeKey}:`) || trimmed.startsWith(`${endTimeKey}:`) || trimmed.startsWith(`${totalTimeKey}:`)) {
          return false;
        }
        return true;
      });
      const newFM = filteredLines.join("\n") + "\n" + lapseFrontmatter;
      const newContent = content.replace(/^---\n[\s\S]*?\n---/, `---
${newFM}---`);
      await this.app.vault.modify(file, newContent);
    } else {
      const newContent = `---
${lapseFrontmatter}---

${content}`;
      await this.app.vault.modify(file, newContent);
    }
    this.invalidateCacheForFile(filePath);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType("lapse-sidebar");
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: "lapse-sidebar", active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async activateReportsView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType("lapse-reports");
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: "lapse-reports", active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async activateButtonsView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType("lapse-buttons");
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: "lapse-buttons", active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async getActiveTimers() {
    const activeTimers = [];
    this.timeData.forEach((pageData, filePath) => {
      pageData.entries.forEach((entry) => {
        if (entry.startTime && !entry.endTime) {
          activeTimers.push({ filePath, entry });
        }
      });
    });
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (this.isFileExcluded(filePath)) {
        continue;
      }
      if (this.timeData.has(filePath)) {
        continue;
      }
      await this.loadEntriesFromFrontmatter(filePath);
      const pageData = this.timeData.get(filePath);
      if (pageData) {
        pageData.entries.forEach((entry) => {
          if (entry.startTime && !entry.endTime) {
            activeTimers.push({ filePath, entry });
          }
        });
      }
    }
    return activeTimers;
  }
  async onunload() {
    if (this.statusBarUpdateInterval) {
      window.clearInterval(this.statusBarUpdateInterval);
      this.statusBarUpdateInterval = null;
    }
    if (this.pendingSaves.length > 0) {
      console.log(`Lapse: Waiting for ${this.pendingSaves.length} pending save(s) to complete...`);
      await Promise.all(this.pendingSaves);
    }
    if (this.cacheSaveTimeout) {
      clearTimeout(this.cacheSaveTimeout);
      await this.saveData({
        ...this.settings,
        entryCache: this.entryCache
      });
      this.cacheSaveTimeout = null;
    }
    console.log("Unloading Lapse plugin");
  }
  async loadSettings() {
    const data = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
    console.log("Lapse: Settings loaded (cache will load on-demand)");
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async saveCache() {
    if (this.cacheSaveTimeout) {
      clearTimeout(this.cacheSaveTimeout);
    }
    const savePromise = new Promise((resolve) => {
      this.cacheSaveTimeout = window.setTimeout(async () => {
        try {
          const data = await this.loadData();
          await this.saveData({
            ...data,
            entryCache: this.entryCache
          });
        } finally {
          this.cacheSaveTimeout = null;
          const index = this.pendingSaves.indexOf(savePromise);
          if (index > -1) {
            this.pendingSaves.splice(index, 1);
          }
          resolve();
        }
      }, 2e3);
    });
    this.pendingSaves.push(savePromise);
    return savePromise;
  }
  invalidateCacheForFile(filePath) {
    delete this.entryCache[filePath];
  }
  async getCachedOrLoadEntries(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return { entries: [], project: null, totalTime: 0 };
    }
    const fileCache = this.app.metadataCache.getFileCache(file);
    const currentMtime = file.stat.mtime;
    const cached = this.entryCache[filePath];
    if (cached && cached.lastModified === currentMtime) {
      return {
        entries: cached.entries,
        project: cached.project,
        totalTime: cached.totalTime
      };
    }
    await this.loadEntriesFromFrontmatter(filePath);
    const pageData = this.timeData.get(filePath);
    const project = await this.getProjectFromFrontmatter(filePath);
    const entries = pageData ? pageData.entries : [];
    const totalTime = pageData ? pageData.totalTimeTracked : 0;
    this.entryCache[filePath] = {
      lastModified: currentMtime,
      entries,
      project,
      totalTime
    };
    this.saveCache();
    return { entries, project, totalTime };
  }
};
var LapseSidebarView = class extends import_obsidian.ItemView {
  // Toggle for showing/hiding the chart section
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshInterval = null;
    this.timeDisplays = /* @__PURE__ */ new Map();
    // Map of entry ID to time display element
    this.showTodayEntries = true;
    // Toggle for showing/hiding individual entries
    this.refreshCounter = 0;
    // Counter for periodic full refreshes
    this.showEntriesList = true;
    // Toggle for showing/hiding the entries list section
    this.showChart = true;
    this.plugin = plugin;
  }
  getViewType() {
    return "lapse-sidebar";
  }
  getDisplayText() {
    return "Activity";
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    await this.render();
  }
  async render() {
    var _a, _b;
    const container = this.containerEl.children[1];
    container.empty();
    this.timeDisplays.clear();
    const header = container.createDiv({ cls: "lapse-sidebar-header" });
    header.createEl("h4", { text: "Activity" });
    const headerButtons = header.createDiv({ cls: "lapse-sidebar-header-buttons" });
    const listBtn = headerButtons.createEl("button", {
      cls: `lapse-sidebar-toggle-view-btn clickable-icon ${this.showEntriesList ? "active" : ""}`,
      attr: { "aria-label": "Toggle entries list" }
    });
    (0, import_obsidian.setIcon)(listBtn, "list");
    listBtn.onclick = () => {
      this.showEntriesList = !this.showEntriesList;
      this.render();
    };
    const chartBtn = headerButtons.createEl("button", {
      cls: `lapse-sidebar-toggle-view-btn clickable-icon ${this.showChart ? "active" : ""}`,
      attr: { "aria-label": "Toggle chart" }
    });
    (0, import_obsidian.setIcon)(chartBtn, "pie-chart");
    chartBtn.onclick = () => {
      this.showChart = !this.showChart;
      this.render();
    };
    const refreshBtn = headerButtons.createEl("button", {
      cls: "lapse-sidebar-refresh-btn clickable-icon",
      attr: { "aria-label": "Refresh" }
    });
    (0, import_obsidian.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.onclick = async () => {
      this.plugin.timeData.clear();
      await this.render();
    };
    const activeTimers = [];
    this.plugin.timeData.forEach((pageData, filePath) => {
      pageData.entries.forEach((entry) => {
        if (entry.startTime && !entry.endTime) {
          activeTimers.push({ filePath, entry });
        }
      });
    });
    if (activeTimers.length === 0) {
      container.createEl("p", { text: "No active timers", cls: "lapse-sidebar-empty" });
    } else {
      for (const { filePath, entry } of activeTimers) {
        const card = container.createDiv({ cls: "lapse-activity-card" });
        const timerRow = card.createDiv({ cls: "lapse-activity-timer-row" });
        const elapsed = entry.duration + (entry.isPaused ? 0 : Date.now() - entry.startTime);
        const timeText = this.plugin.formatTimeAsHHMMSS(elapsed);
        const timerDisplay = timerRow.createDiv({
          text: timeText,
          cls: "lapse-activity-timer"
        });
        this.timeDisplays.set(entry.id, timerDisplay);
        const stopBtn = timerRow.createEl("button", {
          cls: "lapse-activity-stop-btn",
          attr: { "aria-label": "Stop timer" }
        });
        (0, import_obsidian.setIcon)(stopBtn, "square");
        stopBtn.onclick = async (e) => {
          e.stopPropagation();
          const pageData = this.plugin.timeData.get(filePath);
          if (pageData) {
            const entryInData = pageData.entries.find((e2) => e2.id === entry.id);
            if (entryInData && entryInData.startTime && !entryInData.endTime) {
              const now = Date.now();
              entryInData.endTime = now;
              entryInData.duration += now - entryInData.startTime;
              entryInData.startTime = null;
              pageData.totalTimeTracked = pageData.entries.reduce((sum, e2) => sum + e2.duration, 0);
              await this.plugin.updateFrontmatter(filePath);
              await this.render();
            }
          }
        };
        const file = this.app.vault.getAbstractFileByPath(filePath);
        let fileName = file && file instanceof import_obsidian.TFile ? file.basename : ((_a = filePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || filePath;
        if (this.plugin.settings.hideTimestampsInViews) {
          fileName = this.plugin.removeTimestampFromFileName(fileName);
        }
        const detailsContainer = card.createDiv({ cls: "lapse-activity-details" });
        const link = detailsContainer.createEl("a", {
          text: fileName,
          cls: "lapse-activity-page internal-link",
          href: filePath
        });
        link.onclick = (e) => {
          e.preventDefault();
          const file2 = this.app.vault.getAbstractFileByPath(filePath);
          if (file2 && file2 instanceof import_obsidian.TFile) {
            this.app.workspace.openLinkText(filePath, "", false);
          }
        };
        const project = await this.plugin.getProjectFromFrontmatter(filePath);
        if (project) {
          const projectColor = await this.plugin.getProjectColor(project);
          const projectEl = detailsContainer.createDiv({ text: project, cls: "lapse-activity-project" });
          if (projectColor) {
            projectEl.style.color = projectColor;
          }
        }
        detailsContainer.createDiv({ text: entry.label, cls: "lapse-activity-label" });
      }
    }
    if (this.showEntriesList) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayStart = today.getTime();
      const todayEntries = [];
      this.plugin.timeData.forEach((pageData, filePath) => {
        pageData.entries.forEach((entry) => {
          if (entry.startTime && entry.startTime >= todayStart && entry.endTime) {
            todayEntries.push({ filePath, entry, startTime: entry.startTime });
          }
        });
      });
      const markdownFiles = this.app.vault.getMarkdownFiles();
      for (const file of markdownFiles) {
        const filePath = file.path;
        if (this.plugin.isFileExcluded(filePath)) {
          continue;
        }
        if (this.plugin.timeData.has(filePath)) {
          continue;
        }
        const { entries: fileEntries } = await this.plugin.getCachedOrLoadEntries(filePath);
        for (const entry of fileEntries) {
          if (entry.startTime && entry.startTime >= todayStart && entry.endTime) {
            todayEntries.push({ filePath, entry, startTime: entry.startTime });
          }
        }
      }
      const entriesByNote = /* @__PURE__ */ new Map();
      todayEntries.forEach(({ filePath, entry, startTime }) => {
        if (!entriesByNote.has(filePath)) {
          entriesByNote.set(filePath, []);
        }
        entriesByNote.get(filePath).push({ entry, startTime });
      });
      entriesByNote.forEach((entries) => {
        entries.sort((a, b) => b.startTime - a.startTime);
      });
      const noteGroups = Array.from(entriesByNote.entries()).map(([filePath, entries]) => {
        const totalTime = entries.reduce((sum, { entry }) => sum + entry.duration, 0);
        const newestStartTime = Math.max(...entries.map((e) => e.startTime));
        return { filePath, entries, totalTime, newestStartTime };
      });
      noteGroups.sort((a, b) => b.newestStartTime - a.newestStartTime);
      if (noteGroups.length > 0) {
        const sectionHeader = container.createDiv({ cls: "lapse-sidebar-section-header" });
        sectionHeader.createEl("h4", { text: "Today's Entries", cls: "lapse-sidebar-section-title" });
        const toggleBtn = sectionHeader.createEl("button", {
          cls: "lapse-sidebar-toggle-btn clickable-icon",
          attr: { "aria-label": this.showTodayEntries ? "Hide entries" : "Show entries" }
        });
        (0, import_obsidian.setIcon)(toggleBtn, this.showTodayEntries ? "chevron-down" : "chevron-right");
        toggleBtn.onclick = () => {
          this.showTodayEntries = !this.showTodayEntries;
          this.render();
        };
        const todayList = container.createEl("ul", { cls: "lapse-sidebar-list" });
        for (const { filePath, entries, totalTime } of noteGroups) {
          const item = todayList.createEl("li", { cls: "lapse-sidebar-note-group" });
          const topLine = item.createDiv({ cls: "lapse-sidebar-top-line" });
          const file = this.app.vault.getAbstractFileByPath(filePath);
          let fileName = file && file instanceof import_obsidian.TFile ? file.basename : ((_b = filePath.split("/").pop()) == null ? void 0 : _b.replace(".md", "")) || filePath;
          if (this.plugin.settings.hideTimestampsInViews) {
            fileName = this.plugin.removeTimestampFromFileName(fileName);
          }
          const link = topLine.createEl("a", {
            text: fileName,
            cls: "internal-link",
            href: filePath
          });
          link.onclick = (e) => {
            e.preventDefault();
            const file2 = this.app.vault.getAbstractFileByPath(filePath);
            if (file2 && file2 instanceof import_obsidian.TFile) {
              this.app.workspace.openLinkText(filePath, "", false);
            }
          };
          const timeText = this.plugin.formatTimeAsHHMMSS(totalTime);
          topLine.createSpan({ text: timeText, cls: "lapse-sidebar-time" });
          const project = await this.plugin.getProjectFromFrontmatter(filePath);
          if (project) {
            const secondLine = item.createDiv({ cls: "lapse-sidebar-second-line" });
            secondLine.createSpan({ text: project, cls: "lapse-sidebar-project" });
          }
          if (this.showTodayEntries) {
            const entriesList = item.createDiv({ cls: "lapse-sidebar-entries-list" });
            entries.forEach(({ entry }) => {
              const entryLine = entriesList.createDiv({ cls: "lapse-sidebar-entry-line" });
              const entryTime = this.plugin.formatTimeAsHHMMSS(entry.duration);
              entryLine.createSpan({ text: entry.label, cls: "lapse-sidebar-entry-label" });
              entryLine.createSpan({ text: entryTime, cls: "lapse-sidebar-entry-time" });
            });
          }
        }
      }
    }
    if (this.showChart) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayStart = today.getTime();
      await this.renderPieChart(container, todayStart);
    }
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    this.refreshInterval = window.setInterval(() => {
      this.updateTimers().catch((err) => console.error("Error updating timers:", err));
    }, 1e3);
  }
  async updateTimers() {
    this.refreshCounter++;
    if (this.refreshCounter >= 30) {
      this.refreshCounter = 0;
      this.plugin.timeData.forEach((pageData, filePath) => {
        this.plugin.invalidateCacheForFile(filePath);
      });
      await this.render();
      return;
    }
    const currentActiveTimers = [];
    this.plugin.timeData.forEach((pageData, filePath) => {
      pageData.entries.forEach((entry) => {
        if (entry.startTime && !entry.endTime) {
          currentActiveTimers.push({ filePath, entry });
        }
      });
    });
    const displayedEntryIds = new Set(this.timeDisplays.keys());
    const activeEntryIds = new Set(currentActiveTimers.map(({ entry }) => entry.id));
    const needsFullRefresh = currentActiveTimers.length !== displayedEntryIds.size || ![...displayedEntryIds].every((id) => activeEntryIds.has(id)) || !currentActiveTimers.every(({ entry }) => displayedEntryIds.has(entry.id));
    if (needsFullRefresh) {
      await this.render();
      return;
    }
    for (const [entryId, timeDisplay] of this.timeDisplays.entries()) {
      let foundEntry = null;
      for (const [filePath, pageData] of this.plugin.timeData) {
        for (const entry of pageData.entries) {
          if (entry.id === entryId && entry.startTime && !entry.endTime) {
            foundEntry = entry;
            break;
          }
        }
        if (foundEntry)
          break;
      }
      if (foundEntry && foundEntry.startTime) {
        const elapsed = foundEntry.duration + (foundEntry.isPaused ? 0 : Date.now() - foundEntry.startTime);
        const timeText = this.plugin.formatTimeAsHHMMSS(elapsed);
        timeDisplay.setText(timeText);
      } else {
        this.timeDisplays.delete(entryId);
        await this.render();
        return;
      }
    }
    if (this.showChart && this.refreshCounter % 5 === 0) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayStart = today.getTime();
      const chartContainer = this.containerEl.querySelector(".lapse-pie-chart-container");
      if (chartContainer) {
      }
    }
  }
  async renderPieChart(container, todayStart) {
    const projectTimes = /* @__PURE__ */ new Map();
    let totalTimeToday = 0;
    for (const [filePath, pageData] of this.plugin.timeData) {
      for (const entry of pageData.entries) {
        if (entry.startTime && entry.startTime >= todayStart) {
          let entryDuration = 0;
          if (entry.endTime !== null) {
            entryDuration = entry.duration;
          } else if (entry.startTime !== null) {
            entryDuration = entry.duration + (Date.now() - entry.startTime);
          }
          if (entryDuration > 0) {
            totalTimeToday += entryDuration;
            const project = await this.plugin.getProjectFromFrontmatter(filePath);
            const projectName = project || "No Project";
            const currentTime = projectTimes.get(projectName) || 0;
            projectTimes.set(projectName, currentTime + entryDuration);
          }
        }
      }
    }
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (this.plugin.isFileExcluded(filePath)) {
        continue;
      }
      if (this.plugin.timeData.has(filePath)) {
        continue;
      }
      const { entries: fileEntries, project } = await this.plugin.getCachedOrLoadEntries(filePath);
      for (const entry of fileEntries) {
        if (entry.startTime && entry.startTime >= todayStart) {
          let entryDuration = 0;
          if (entry.endTime !== null) {
            entryDuration = entry.duration;
          } else if (entry.startTime !== null) {
            entryDuration = entry.duration + (Date.now() - entry.startTime);
          }
          if (entryDuration > 0) {
            totalTimeToday += entryDuration;
            const projectName = project || "No Project";
            const currentTime = projectTimes.get(projectName) || 0;
            projectTimes.set(projectName, currentTime + entryDuration);
          }
        }
      }
    }
    if (totalTimeToday === 0) {
      return;
    }
    const chartSection = container.createDiv({ cls: "lapse-sidebar-chart-section" });
    chartSection.createEl("h4", { text: "Today's Summary", cls: "lapse-sidebar-section-title" });
    const totalTimeDiv = chartSection.createDiv({ cls: "lapse-sidebar-total-time" });
    totalTimeDiv.setText(this.plugin.formatTimeAsHHMMSS(totalTimeToday));
    const chartContainer = chartSection.createDiv({ cls: "lapse-sidebar-chart-container" });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "lapse-sidebar-pie-chart");
    svg.setAttribute("width", "200");
    svg.setAttribute("height", "200");
    svg.setAttribute("viewBox", "0 0 200 200");
    chartContainer.appendChild(svg);
    const defaultColors = [
      "#4A90E2",
      "#50C878",
      "#FF6B6B",
      "#FFD93D",
      "#9B59B6",
      "#E67E22",
      "#1ABC9C",
      "#E74C3C",
      "#3498DB",
      "#2ECC71",
      "#F39C12",
      "#16A085"
    ];
    const projectData = await Promise.all(
      Array.from(projectTimes.entries()).sort((a, b) => b[1] - a[1]).map(async ([name, time], index) => {
        const projectColor = await this.plugin.getProjectColor(name);
        return {
          name,
          time,
          color: projectColor || defaultColors[index % defaultColors.length]
        };
      })
    );
    let currentAngle = -Math.PI / 2;
    const centerX = 100;
    const centerY = 100;
    const radius = 80;
    projectData.forEach(({ name, time, color }) => {
      const percentage = time / totalTimeToday;
      const angle = percentage * 2 * Math.PI;
      const startAngle = currentAngle;
      const endAngle = currentAngle + angle;
      const x1 = centerX + radius * Math.cos(startAngle);
      const y1 = centerY + radius * Math.sin(startAngle);
      const x2 = centerX + radius * Math.cos(endAngle);
      const y2 = centerY + radius * Math.sin(endAngle);
      const largeArc = angle > Math.PI ? 1 : 0;
      const pathData = [
        `M ${centerX} ${centerY}`,
        `L ${x1} ${y1}`,
        `A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`,
        "Z"
      ].join(" ");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", pathData);
      path.setAttribute("fill", color);
      path.setAttribute("stroke", "var(--background-primary)");
      path.setAttribute("stroke-width", "2");
      svg.appendChild(path);
      currentAngle += angle;
    });
    const legend = chartSection.createDiv({ cls: "lapse-sidebar-chart-legend" });
    projectData.forEach(({ name, time, color }) => {
      const legendItem = legend.createDiv({ cls: "lapse-sidebar-legend-item" });
      const colorBox = legendItem.createDiv({ cls: "lapse-sidebar-legend-color" });
      colorBox.style.backgroundColor = color;
      const label = legendItem.createDiv({ cls: "lapse-sidebar-legend-label" });
      const nameSpan = label.createSpan({ text: name });
      nameSpan.style.color = color;
      const timeSpan = label.createSpan({
        text: this.plugin.formatTimeAsHHMMSS(time),
        cls: "lapse-sidebar-legend-time"
      });
    });
  }
  async refresh() {
    await this.render();
  }
  async onClose() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }
};
var LapseButtonsView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return "lapse-buttons";
  }
  getDisplayText() {
    return "Quick Start";
  }
  getIcon() {
    return "play-circle";
  }
  async onOpen() {
    await this.render();
  }
  async onClose() {
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("lapse-buttons-view");
    const header = container.createDiv({ cls: "lapse-buttons-header" });
    header.createEl("h2", { text: "Quick Start" });
    const headerButtons = header.createDiv({ cls: "lapse-buttons-header-buttons" });
    const refreshBtn = headerButtons.createEl("button", {
      cls: "lapse-buttons-refresh-btn clickable-icon",
      attr: { "aria-label": "Refresh" }
    });
    (0, import_obsidian.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.onclick = async () => {
      await this.render();
    };
    const templateFolder = this.plugin.settings.lapseButtonTemplatesFolder;
    const files = this.app.vault.getMarkdownFiles();
    const templates = files.filter((file) => file.path.startsWith(templateFolder + "/"));
    if (templates.length === 0) {
      container.createEl("p", {
        text: `No templates found in ${templateFolder}. Configure your template folder in Lapse settings.`,
        cls: "lapse-buttons-empty"
      });
      return;
    }
    const templateDataList = [];
    for (const template of templates) {
      const templateName = template.basename;
      let project = null;
      let projectColor = null;
      try {
        const content = await this.app.vault.read(template);
        const frontmatterRegex = /---\n([\s\S]*?)\n---/;
        const match = content.match(frontmatterRegex);
        if (match) {
          const frontmatter = match[1];
          const lines = frontmatter.split("\n");
          for (const line of lines) {
            if (line.trim().startsWith(this.plugin.settings.projectKey + ":")) {
              project = line.split(":").slice(1).join(":").trim();
              if (project) {
                project = project.replace(/\[\[/g, "").replace(/\]\]/g, "");
                project = project.replace(/^["']+|["']+$/g, "");
                project = project.trim();
              }
              break;
            }
          }
        }
        if (project) {
          projectColor = await this.plugin.getProjectColor(project);
        }
      } catch (error) {
        console.error("Error reading template:", error);
      }
      templateDataList.push({
        template,
        templateName,
        project,
        projectColor
      });
    }
    const grouped = /* @__PURE__ */ new Map();
    for (const data of templateDataList) {
      const projectKey = data.project || "No Project";
      if (!grouped.has(projectKey)) {
        grouped.set(projectKey, []);
      }
      grouped.get(projectKey).push(data);
    }
    const sortedProjects = Array.from(grouped.keys()).sort((a, b) => {
      if (a === "No Project")
        return 1;
      if (b === "No Project")
        return -1;
      return a.localeCompare(b);
    });
    for (const projectKey of sortedProjects) {
      const projectTemplates = grouped.get(projectKey);
      const projectSection = container.createDiv({ cls: "lapse-buttons-project-section" });
      const projectHeader = projectSection.createDiv({ cls: "lapse-buttons-project-header" });
      if (projectKey !== "No Project") {
        const projectColor = projectTemplates[0].projectColor;
        projectHeader.createEl("h3", {
          text: projectKey,
          cls: "lapse-buttons-project-title"
        });
        if (projectColor) {
          projectHeader.style.borderLeftColor = projectColor;
          projectHeader.querySelector("h3").style.color = projectColor;
        }
      } else {
        projectHeader.createEl("h3", {
          text: projectKey,
          cls: "lapse-buttons-project-title"
        });
      }
      const buttonsGrid = projectSection.createDiv({ cls: "lapse-buttons-grid" });
      for (const data of projectTemplates) {
        const button = buttonsGrid.createEl("button", { cls: "lapse-button" });
        const topLine = button.createDiv({ cls: "lapse-button-name" });
        topLine.style.display = "flex";
        topLine.style.justifyContent = "flex-start";
        topLine.style.alignItems = "center";
        topLine.style.gap = "8px";
        topLine.style.minWidth = "0";
        const titleEl = topLine.createSpan({ cls: "lapse-button-title" });
        titleEl.textContent = data.templateName;
        titleEl.style.overflow = "hidden";
        titleEl.style.textOverflow = "ellipsis";
        titleEl.style.whiteSpace = "nowrap";
        titleEl.style.flex = "1";
        titleEl.style.minWidth = "0";
        titleEl.style.textAlign = "left";
        if (this.plugin.settings.showDurationOnNoteButtons) {
          try {
            const duration = await this.plugin.getTemplateButtonDuration(data.templateName, data.project);
            if (duration > 0) {
              const durationText = this.plugin.formatTimeForButton(duration);
              const durationEl = topLine.createSpan({ cls: "lapse-button-duration" });
              durationEl.textContent = durationText;
              durationEl.style.flexShrink = "0";
              durationEl.style.marginLeft = "auto";
            }
          } catch (error) {
            console.error("Error calculating duration for Quick Start button:", error);
          }
        }
        if (data.project) {
          const projectEl = button.createDiv({ cls: "lapse-button-project" });
          projectEl.textContent = data.project;
          if (data.projectColor) {
            button.style.borderLeftColor = data.projectColor;
            projectEl.style.backgroundColor = data.projectColor;
            const contrastColor = this.plugin.getContrastColor(data.projectColor);
            projectEl.style.color = contrastColor;
          }
        }
        button.onclick = async () => {
          try {
            const templateContent = await this.app.vault.read(data.template);
            const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
            const newNoteName = `${data.templateName} ${timestamp}`;
            const newNotePath = `${newNoteName}.md`;
            const newFile = await this.app.vault.create(newNotePath, templateContent);
            await this.app.workspace.getLeaf(false).openFile(newFile);
          } catch (error) {
            console.error("Error creating note from template:", error);
          }
        };
      }
    }
  }
};
var LapseButtonModal = class extends import_obsidian.Modal {
  constructor(app, plugin, onChoose) {
    super(app);
    this.plugin = plugin;
    this.onChoose = onChoose;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select template" });
    const templateFolder = this.plugin.settings.lapseButtonTemplatesFolder;
    const files = this.app.vault.getMarkdownFiles();
    const templates = files.filter((file) => file.path.startsWith(templateFolder + "/"));
    if (templates.length === 0) {
      contentEl.createEl("p", {
        text: `No templates found in ${templateFolder}`,
        cls: "mod-warning"
      });
      return;
    }
    const templateList = contentEl.createDiv({ cls: "lapse-template-list" });
    templates.forEach((template) => {
      const templateName = template.basename;
      const button = templateList.createEl("button", {
        text: templateName,
        cls: "lapse-template-option"
      });
      button.onclick = () => {
        this.onChoose(templateName);
        this.close();
      };
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LapseSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Frontmatter Keys" });
    new import_obsidian.Setting(containerEl).setName("Start Time Key").setDesc("Frontmatter key for start time").addText((text) => text.setPlaceholder("startTime").setValue(this.plugin.settings.startTimeKey).onChange(async (value) => {
      this.plugin.settings.startTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("End Time Key").setDesc("Frontmatter key for end time").addText((text) => text.setPlaceholder("endTime").setValue(this.plugin.settings.endTimeKey).onChange(async (value) => {
      this.plugin.settings.endTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Total Time Key").setDesc("Frontmatter key for total time tracked").addText((text) => text.setPlaceholder("totalTimeTracked").setValue(this.plugin.settings.totalTimeKey).onChange(async (value) => {
      this.plugin.settings.totalTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Project Key").setDesc("Frontmatter key for project name").addText((text) => text.setPlaceholder("project").setValue(this.plugin.settings.projectKey).onChange(async (value) => {
      this.plugin.settings.projectKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Default Time Entry Label" });
    new import_obsidian.Setting(containerEl).setName("Label Type").setDesc("How to determine the default label for new time entries").addDropdown((dropdown) => dropdown.addOption("freeText", "Free Text").addOption("frontmatter", "Frontmatter").addOption("fileName", "File Name").setValue(this.plugin.settings.defaultLabelType).onChange(async (value) => {
      this.plugin.settings.defaultLabelType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.defaultLabelType === "freeText") {
      new import_obsidian.Setting(containerEl).setName("Default Label Text").setDesc("Default text to use for new time entries").addText((text) => text.setPlaceholder("Enter default label").setValue(this.plugin.settings.defaultLabelText).onChange(async (value) => {
        this.plugin.settings.defaultLabelText = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.defaultLabelType === "frontmatter") {
      new import_obsidian.Setting(containerEl).setName("Frontmatter Key").setDesc("Frontmatter key to use for default label").addText((text) => text.setPlaceholder("project").setValue(this.plugin.settings.defaultLabelFrontmatterKey).onChange(async (value) => {
        this.plugin.settings.defaultLabelFrontmatterKey = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.defaultLabelType === "fileName") {
      new import_obsidian.Setting(containerEl).setName("Remove timestamp from filename").setDesc("When enabled, removes date and time stamps from filenames when setting the default label").addToggle((toggle) => toggle.setValue(this.plugin.settings.removeTimestampFromFileName).onChange(async (value) => {
        this.plugin.settings.removeTimestampFromFileName = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Display Options" });
    new import_obsidian.Setting(containerEl).setName("Hide timestamps in views").setDesc("When enabled, removes the display of timestamps in note titles in Active Timers and Time Reports views. This does not change the name of any note, just hides the timestamp for cleaner display.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideTimestampsInViews).onChange(async (value) => {
      this.plugin.settings.hideTimestampsInViews = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show status bar").setDesc("Display active timer(s) in the status bar at the bottom of Obsidian").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStatusBar).onChange(async (value) => {
      this.plugin.settings.showStatusBar = value;
      await this.plugin.saveSettings();
      if (value) {
        if (!this.plugin.statusBarItem) {
          this.plugin.statusBarItem = this.plugin.addStatusBarItem();
          this.plugin.statusBarItem.addClass("lapse-status-bar");
        }
        this.plugin.updateStatusBar();
        if (!this.plugin.statusBarUpdateInterval) {
          this.plugin.statusBarUpdateInterval = window.setInterval(() => {
            this.plugin.updateStatusBar();
          }, 1e3);
        }
      } else {
        if (this.plugin.statusBarUpdateInterval) {
          window.clearInterval(this.plugin.statusBarUpdateInterval);
          this.plugin.statusBarUpdateInterval = null;
        }
        if (this.plugin.statusBarItem) {
          this.plugin.statusBarItem.setText("");
          this.plugin.statusBarItem.hide();
        }
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Show duration on note buttons").setDesc("Display task duration on inline lapse buttons (e.g., `lapse:Dishes`)").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDurationOnNoteButtons).onChange(async (value) => {
      this.plugin.settings.showDurationOnNoteButtons = value;
      await this.plugin.saveSettings();
      this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
        if (leaf.view instanceof LapseSidebarView) {
          leaf.view.refresh();
        }
      });
    }));
    if (this.plugin.settings.showDurationOnNoteButtons) {
      new import_obsidian.Setting(containerEl).setName("Duration type").setDesc("Project: aggregate time from all notes with the same project. Note: aggregate time from all notes with the same base filename (ignoring timestamp).").addDropdown((dropdown) => dropdown.addOption("project", "Project").addOption("note", "Note").setValue(this.plugin.settings.noteButtonDurationType).onChange(async (value) => {
        this.plugin.settings.noteButtonDurationType = value;
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      }));
      new import_obsidian.Setting(containerEl).setName("Time period").setDesc("Select the time period for duration calculation").addDropdown((dropdown) => dropdown.addOption("today", "Today").addOption("thisWeek", "This Week").addOption("thisMonth", "This Month").addOption("lastWeek", "Last Week").addOption("lastMonth", "Last Month").setValue(this.plugin.settings.noteButtonTimePeriod).onChange(async (value) => {
        this.plugin.settings.noteButtonTimePeriod = value;
        await this.plugin.saveSettings();
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      }));
    }
    new import_obsidian.Setting(containerEl).setName("First day of week").setDesc("Set the first day of the week for weekly reports").addDropdown((dropdown) => dropdown.addOption("0", "Sunday").addOption("1", "Monday").addOption("2", "Tuesday").addOption("3", "Wednesday").addOption("4", "Thursday").addOption("5", "Friday").addOption("6", "Saturday").setValue(this.plugin.settings.firstDayOfWeek.toString()).onChange(async (value) => {
      this.plugin.settings.firstDayOfWeek = parseInt(value);
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Tags" });
    new import_obsidian.Setting(containerEl).setName("Default tag on note").setDesc("Tag to add to notes when time entries are created (e.g., #lapse)").addText((text) => text.setPlaceholder("#lapse").setValue(this.plugin.settings.defaultTagOnNote).onChange(async (value) => {
      this.plugin.settings.defaultTagOnNote = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default tag on time entries").setDesc("Tag to automatically add to new time entries (leave empty for none, e.g., #work)").addText((text) => text.setPlaceholder("#work").setValue(this.plugin.settings.defaultTagOnTimeEntries).onChange(async (value) => {
      this.plugin.settings.defaultTagOnTimeEntries = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Lapse Button Templates" });
    new import_obsidian.Setting(containerEl).setName("Templates folder").setDesc("Folder path containing templates for lapse-button inline buttons (e.g., Templates/Lapse Buttons). Templates should be in your vault's template folder.").addText((text) => text.setPlaceholder("Templates/Lapse Buttons").setValue(this.plugin.settings.lapseButtonTemplatesFolder).onChange(async (value) => {
      this.plugin.settings.lapseButtonTemplatesFolder = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createDiv({ cls: "setting-item-description" }).createEl("p", {
      text: "Create buttons in notes using inline code: `lapse:TemplateName`. The button will create a new note from the template and open it."
    });
    containerEl.createEl("h3", { text: "Timer Controls" });
    new import_obsidian.Setting(containerEl).setName("Show seconds").setDesc("Display seconds in timer").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSeconds).onChange(async (value) => {
      this.plugin.settings.showSeconds = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Time Adjustment").setDesc("Number of minutes to adjust start time with << and >> buttons").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.timeAdjustMinutes.toString()).onChange(async (value) => {
      const numValue = parseInt(value) || 5;
      this.plugin.settings.timeAdjustMinutes = numValue;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Performance" });
    new import_obsidian.Setting(containerEl).setName("Excluded folders").setDesc("Folders to exclude from time tracking (one pattern per line). Supports glob patterns like */2020/* or **/Archive/**").addTextArea((text) => {
      text.setPlaceholder("Templates\n*/2020/*\n**/Archive/**").setValue(this.plugin.settings.excludedFolders.join("\n")).onChange(async (value) => {
        this.plugin.settings.excludedFolders = value.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 6;
      text.inputEl.cols = 40;
    });
    containerEl.createDiv({ cls: "setting-item-description" }).createEl("div", { text: "Example patterns:", cls: "setting-item-description" }).createEl("ul", {}, (ul) => {
      ul.createEl("li", { text: "Templates - Exact folder name" });
      ul.createEl("li", { text: "*/2020/* - 2020 folder one level deep" });
      ul.createEl("li", { text: "**/2020/** - 2020 folder at any depth" });
      ul.createEl("li", { text: "**/Archive - Any folder ending in Archive" });
    });
    containerEl.createEl("hr", { cls: "lapse-settings-divider" });
    const githubLinkContainer = containerEl.createDiv({ cls: "lapse-settings-footer" });
    const githubLink = githubLinkContainer.createEl("a", {
      text: "Report an issue on GitHub",
      href: "https://github.com/jimmy-little/obsidian-lapse-tracker/issues/new",
      cls: "lapse-github-link"
    });
    githubLink.setAttr("target", "_blank");
    githubLink.setAttr("rel", "noopener noreferrer");
  }
};
var LapseReportsView = class extends import_obsidian.ItemView {
  // Track which groups are expanded
  constructor(leaf, plugin) {
    super(leaf);
    this.dateFilter = "today";
    this.customStartDate = "";
    this.customEndDate = "";
    this.groupBy = "note";
    this.secondaryGroupBy = "none";
    this.expandedGroups = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  getViewType() {
    return "lapse-reports";
  }
  getDisplayText() {
    return "Time Reports";
  }
  getIcon() {
    return "bar-chart-2";
  }
  async onOpen() {
    await this.render();
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    const header = container.createDiv({ cls: "lapse-reports-header" });
    const controlsContainer = header.createDiv({ cls: "lapse-reports-controls" });
    const dateFilterSetting = controlsContainer.createDiv({ cls: "lapse-reports-groupby" });
    dateFilterSetting.createEl("label", { text: "Period: " });
    const dateFilterSelect = dateFilterSetting.createEl("select", { cls: "lapse-reports-select" });
    dateFilterSelect.createEl("option", { text: "Today", value: "today" });
    dateFilterSelect.createEl("option", { text: "This Week", value: "thisWeek" });
    dateFilterSelect.createEl("option", { text: "This Month", value: "thisMonth" });
    dateFilterSelect.createEl("option", { text: "Last Week", value: "lastWeek" });
    dateFilterSelect.createEl("option", { text: "Last Month", value: "lastMonth" });
    dateFilterSelect.createEl("option", { text: "Choose...", value: "custom" });
    dateFilterSelect.value = this.dateFilter;
    dateFilterSelect.onchange = async () => {
      this.dateFilter = dateFilterSelect.value;
      await this.render();
    };
    const groupBySetting = controlsContainer.createDiv({ cls: "lapse-reports-groupby" });
    groupBySetting.createEl("label", { text: "Group by: " });
    const groupBySelect = groupBySetting.createEl("select", { cls: "lapse-reports-select" });
    groupBySelect.createEl("option", { text: "Note", value: "note" });
    groupBySelect.createEl("option", { text: "Project", value: "project" });
    groupBySelect.createEl("option", { text: "Tag", value: "tag" });
    groupBySelect.createEl("option", { text: "Date", value: "date" });
    groupBySelect.value = this.groupBy;
    groupBySelect.onchange = async () => {
      this.groupBy = groupBySelect.value;
      await this.render();
    };
    const secondaryGroupBySetting = controlsContainer.createDiv({ cls: "lapse-reports-groupby" });
    secondaryGroupBySetting.createEl("label", { text: "Then by: " });
    const secondaryGroupBySelect = secondaryGroupBySetting.createEl("select", { cls: "lapse-reports-select" });
    secondaryGroupBySelect.createEl("option", { text: "None", value: "none" });
    secondaryGroupBySelect.createEl("option", { text: "Note", value: "note" });
    secondaryGroupBySelect.createEl("option", { text: "Project", value: "project" });
    secondaryGroupBySelect.createEl("option", { text: "Tag", value: "tag" });
    secondaryGroupBySelect.createEl("option", { text: "Date", value: "date" });
    secondaryGroupBySelect.value = this.secondaryGroupBy;
    secondaryGroupBySelect.onchange = async () => {
      this.secondaryGroupBy = secondaryGroupBySelect.value;
      await this.render();
    };
    if (this.dateFilter === "custom") {
      const customDateRow = container.createDiv({ cls: "lapse-reports-custom-date" });
      customDateRow.createEl("label", { text: "Start: " });
      const startDateInput = customDateRow.createEl("input", {
        type: "date",
        cls: "lapse-date-input"
      });
      startDateInput.value = this.customStartDate || new Date().toISOString().split("T")[0];
      customDateRow.createEl("label", { text: "End: " });
      const endDateInput = customDateRow.createEl("input", {
        type: "date",
        cls: "lapse-date-input"
      });
      endDateInput.value = this.customEndDate || new Date().toISOString().split("T")[0];
      const applyBtn = customDateRow.createEl("button", {
        text: "Apply",
        cls: "lapse-apply-btn"
      });
      applyBtn.onclick = async () => {
        this.customStartDate = startDateInput.value;
        this.customEndDate = endDateInput.value;
        await this.render();
      };
    }
    const data = await this.getReportData();
    const summary = container.createDiv({ cls: "lapse-reports-summary" });
    const totalTime = data.reduce((sum, item) => sum + item.totalTime, 0);
    summary.createEl("h3", { text: `Total: ${this.plugin.formatTimeAsHHMMSS(totalTime)}` });
    const tableContainer = container.createDiv({ cls: "lapse-reports-table-container" });
    const table = tableContainer.createEl("table", { cls: "lapse-reports-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "" });
    headerRow.createEl("th", { text: this.getGroupByLabel() });
    headerRow.createEl("th", { text: "Project" });
    headerRow.createEl("th", { text: "Tags" });
    headerRow.createEl("th", { text: "Time" });
    headerRow.createEl("th", { text: "Entries" });
    const tbody = table.createEl("tbody");
    const sortedData = [...data].sort((a, b) => b.totalTime - a.totalTime);
    for (const item of sortedData) {
      const row = tbody.createEl("tr", { cls: "lapse-reports-group-row" });
      const expandCell = row.createEl("td", { cls: "lapse-reports-expand-cell" });
      const expandBtn = expandCell.createEl("span", { cls: "lapse-reports-expand-btn" });
      const groupId = `group-${item.group}`;
      const isExpanded = this.expandedGroups.has(groupId);
      (0, import_obsidian.setIcon)(expandBtn, isExpanded ? "chevron-down" : "chevron-right");
      row.createEl("td", { text: item.group, cls: "lapse-reports-group-name" });
      const projects = new Set(item.entries.map((e) => e.project).filter((p) => p));
      const allTags = /* @__PURE__ */ new Set();
      item.entries.forEach((e) => {
        var _a;
        return (_a = e.entry.tags) == null ? void 0 : _a.forEach((t) => allTags.add(t));
      });
      const projectCell = row.createEl("td");
      if (projects.size > 0) {
        const projectArray = Array.from(projects).filter((p) => p !== null);
        for (let i = 0; i < projectArray.length; i++) {
          const projectName = projectArray[i];
          const projectColor = await this.plugin.getProjectColor(projectName);
          const projectSpan = projectCell.createSpan({ text: projectName });
          if (projectColor) {
            projectSpan.style.color = projectColor;
          }
          if (i < projectArray.length - 1) {
            projectCell.createSpan({ text: ", " });
          }
        }
      } else {
        projectCell.setText("-");
      }
      row.createEl("td", { text: allTags.size > 0 ? Array.from(allTags).map((t) => `#${t}`).join(", ") : "-" });
      row.createEl("td", { text: this.plugin.formatTimeAsHHMMSS(item.totalTime) });
      row.createEl("td", { text: item.entryCount.toString() });
      row.style.cursor = "pointer";
      row.onclick = () => {
        if (this.expandedGroups.has(groupId)) {
          this.expandedGroups.delete(groupId);
        } else {
          this.expandedGroups.add(groupId);
        }
        this.render();
      };
      if (isExpanded) {
        if (item.subGroups && item.subGroups.size > 0) {
          for (const [subGroupName, subGroup] of item.subGroups) {
            const subRow = tbody.createEl("tr", { cls: "lapse-reports-subgroup-row" });
            subRow.createEl("td");
            subRow.createEl("td", { text: `  ${subGroupName}`, cls: "lapse-reports-subgroup-name" });
            const subProjects = new Set(subGroup.entries.map((e) => e.project).filter((p) => p));
            const subTags = /* @__PURE__ */ new Set();
            subGroup.entries.forEach((e) => {
              var _a;
              return (_a = e.entry.tags) == null ? void 0 : _a.forEach((t) => subTags.add(t));
            });
            const subProjectCell = subRow.createEl("td");
            if (subProjects.size > 0) {
              const subProjectArray = Array.from(subProjects).filter((p) => p !== null);
              for (let i = 0; i < subProjectArray.length; i++) {
                const projectName = subProjectArray[i];
                const projectColor = await this.plugin.getProjectColor(projectName);
                const projectSpan = subProjectCell.createSpan({ text: projectName });
                if (projectColor) {
                  projectSpan.style.color = projectColor;
                }
                if (i < subProjectArray.length - 1) {
                  subProjectCell.createSpan({ text: ", " });
                }
              }
            } else {
              subProjectCell.setText("-");
            }
            subRow.createEl("td", { text: subTags.size > 0 ? Array.from(subTags).map((t) => `#${t}`).join(", ") : "-" });
            subRow.createEl("td", { text: this.plugin.formatTimeAsHHMMSS(subGroup.totalTime) });
            subRow.createEl("td", { text: subGroup.entryCount.toString() });
          }
        } else {
          for (const { entry, noteName, project } of item.entries) {
            const entryRow = tbody.createEl("tr", { cls: "lapse-reports-entry-row" });
            entryRow.createEl("td");
            entryRow.createEl("td", { text: `  ${entry.label}`, cls: "lapse-reports-entry-label" });
            const entryProjectCell = entryRow.createEl("td");
            if (project) {
              const projectColor = await this.plugin.getProjectColor(project);
              const projectSpan = entryProjectCell.createSpan({ text: project });
              if (projectColor) {
                projectSpan.style.color = projectColor;
              }
            } else {
              entryProjectCell.setText("-");
            }
            entryRow.createEl("td", { text: entry.tags && entry.tags.length > 0 ? entry.tags.map((t) => `#${t}`).join(", ") : "-" });
            const entryDuration = entry.endTime ? entry.duration : entry.duration + (Date.now() - entry.startTime);
            entryRow.createEl("td", { text: this.plugin.formatTimeAsHHMMSS(entryDuration) });
            entryRow.createEl("td", { text: noteName, cls: "lapse-reports-note-name" });
          }
        }
      }
    }
    if (data.length > 0) {
      const chartContainer = container.createDiv({ cls: "lapse-reports-chart-container" });
      await this.renderChart(chartContainer, data, totalTime);
    }
  }
  getGroupByLabel() {
    switch (this.groupBy) {
      case "note":
        return "Note";
      case "project":
        return "Project";
      case "tag":
        return "Tag";
      case "date":
        return "Date";
      default:
        return "Group";
    }
  }
  getGroupKey(entry, filePath, project, groupType) {
    if (groupType === "none")
      return "All";
    if (groupType === "note") {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      let noteName = file && file instanceof import_obsidian.TFile ? file.basename : filePath;
      if (this.plugin.settings.hideTimestampsInViews) {
        noteName = this.plugin.removeTimestampFromFileName(noteName);
      }
      return noteName;
    } else if (groupType === "project") {
      if (project) {
        const parts = project.split("/");
        return parts[parts.length - 1];
      }
      return "No Project";
    } else if (groupType === "tag") {
      if (entry.tags && entry.tags.length > 0) {
        return `#${entry.tags[0]}`;
      }
      return "No Tag";
    } else {
      const date = new Date(entry.startTime);
      return date.toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" });
    }
  }
  async getReportData() {
    const now = new Date();
    let startDate;
    let endDate = new Date(now);
    if (this.dateFilter === "today") {
      startDate = new Date(now);
      startDate.setHours(0, 0, 0, 0);
    } else if (this.dateFilter === "thisWeek") {
      startDate = new Date(now);
      const dayOfWeek = startDate.getDay();
      const daysFromFirstDay = (dayOfWeek - this.plugin.settings.firstDayOfWeek + 7) % 7;
      startDate.setDate(startDate.getDate() - daysFromFirstDay);
      startDate.setHours(0, 0, 0, 0);
    } else if (this.dateFilter === "thisMonth") {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      startDate.setHours(0, 0, 0, 0);
    } else if (this.dateFilter === "lastWeek") {
      const firstDayOfWeek = this.plugin.settings.firstDayOfWeek;
      const today = new Date(now);
      const dayOfWeek = today.getDay();
      const daysFromFirstDay = (dayOfWeek - firstDayOfWeek + 7) % 7;
      startDate = new Date(today);
      startDate.setDate(today.getDate() - daysFromFirstDay - 7);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(startDate);
      endDate.setDate(startDate.getDate() + 6);
      endDate.setHours(23, 59, 59, 999);
    } else if (this.dateFilter === "lastMonth") {
      const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      startDate = new Date(lastMonth);
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(now.getFullYear(), now.getMonth(), 0);
      endDate.setHours(23, 59, 59, 999);
    } else {
      if (this.customStartDate && this.customEndDate) {
        startDate = new Date(this.customStartDate);
        startDate.setHours(0, 0, 0, 0);
        endDate = new Date(this.customEndDate);
        endDate.setHours(23, 59, 59, 999);
      } else {
        startDate = new Date(now);
        startDate.setHours(0, 0, 0, 0);
      }
    }
    const startTime = startDate.getTime();
    const endTime = endDate.getTime();
    const entries = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (this.plugin.isFileExcluded(filePath)) {
        continue;
      }
      const { entries: fileEntries, project } = await this.plugin.getCachedOrLoadEntries(filePath);
      for (const entry of fileEntries) {
        if (entry.startTime && entry.startTime >= startTime && entry.startTime <= endTime) {
          if (entry.endTime || entry.startTime && !entry.endTime) {
            let noteName = file.basename;
            if (this.plugin.settings.hideTimestampsInViews) {
              noteName = this.plugin.removeTimestampFromFileName(noteName);
            }
            entries.push({ filePath, entry, project, noteName });
          }
        }
      }
    }
    const grouped = /* @__PURE__ */ new Map();
    for (const { filePath, entry, project, noteName } of entries) {
      const primaryKey = this.getGroupKey(entry, filePath, project, this.groupBy);
      if (!grouped.has(primaryKey)) {
        grouped.set(primaryKey, {
          totalTime: 0,
          entryCount: 0,
          entries: [],
          subGroups: this.secondaryGroupBy !== "none" ? /* @__PURE__ */ new Map() : void 0
        });
      }
      const entryDuration = entry.endTime ? entry.duration : entry.duration + (Date.now() - entry.startTime);
      const primaryGroup = grouped.get(primaryKey);
      primaryGroup.totalTime += entryDuration;
      primaryGroup.entryCount++;
      primaryGroup.entries.push({ entry, filePath, project, noteName });
      if (this.secondaryGroupBy !== "none" && primaryGroup.subGroups) {
        const secondaryKey = this.getGroupKey(entry, filePath, project, this.secondaryGroupBy);
        if (!primaryGroup.subGroups.has(secondaryKey)) {
          primaryGroup.subGroups.set(secondaryKey, {
            totalTime: 0,
            entryCount: 0,
            entries: []
          });
        }
        const secondaryGroup = primaryGroup.subGroups.get(secondaryKey);
        secondaryGroup.totalTime += entryDuration;
        secondaryGroup.entryCount++;
        secondaryGroup.entries.push({ entry, filePath, project, noteName });
      }
    }
    return Array.from(grouped.entries()).map(([group, stats]) => ({
      group,
      totalTime: stats.totalTime,
      entryCount: stats.entryCount,
      entries: stats.entries,
      subGroups: stats.subGroups
    }));
  }
  async renderChart(container, data, totalTime) {
    container.empty();
    container.createEl("h4", { text: "Time Distribution" });
    const viewBoxWidth = 1e3;
    const chartHeight = 250;
    const labelHeight = 80;
    const totalHeight = chartHeight + labelHeight;
    const padding = 40;
    const chartAreaWidth = viewBoxWidth - padding * 2;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "lapse-reports-chart");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "300");
    svg.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${totalHeight}`);
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    container.appendChild(svg);
    const maxTime = Math.max(...data.map((d) => d.totalTime));
    const barCount = data.length;
    const barWidth = chartAreaWidth / barCount;
    const maxBarHeight = chartHeight - padding * 2;
    const defaultColors = [
      "#4A90E2",
      "#50C878",
      "#FF6B6B",
      "#FFD93D",
      "#9B59B6",
      "#E67E22",
      "#1ABC9C",
      "#E74C3C"
    ];
    const isGroupingByProject = this.groupBy === "project";
    const dataWithColors = await Promise.all(data.map(async (item, index) => {
      let color = defaultColors[index % defaultColors.length];
      if (isGroupingByProject) {
        const projectColor = await this.plugin.getProjectColor(item.group);
        if (projectColor) {
          color = projectColor;
        }
      }
      return { ...item, color };
    }));
    dataWithColors.forEach((item, index) => {
      const barHeight = maxTime > 0 ? item.totalTime / maxTime * maxBarHeight : 0;
      const x = padding + index * barWidth;
      const y = chartHeight - padding - barHeight;
      const barGap = barWidth * 0.1;
      const actualBarWidth = barWidth - barGap;
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("x", (x + barGap / 2).toString());
      rect.setAttribute("y", y.toString());
      rect.setAttribute("width", actualBarWidth.toString());
      rect.setAttribute("height", barHeight.toString());
      rect.setAttribute("fill", item.color);
      rect.setAttribute("rx", "4");
      svg.appendChild(rect);
      const labelY = chartHeight + 10;
      const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
      foreignObject.setAttribute("x", (x + barGap / 2).toString());
      foreignObject.setAttribute("y", labelY.toString());
      foreignObject.setAttribute("width", actualBarWidth.toString());
      foreignObject.setAttribute("height", labelHeight.toString());
      const labelDiv = document.createElement("div");
      labelDiv.setAttribute("class", "lapse-chart-label");
      labelDiv.style.width = "100%";
      labelDiv.style.height = "100%";
      labelDiv.style.display = "flex";
      labelDiv.style.alignItems = "flex-start";
      labelDiv.style.justifyContent = "center";
      labelDiv.style.fontSize = barCount > 15 ? "9px" : barCount > 10 ? "10px" : "11px";
      labelDiv.style.color = isGroupingByProject ? item.color : "var(--text-muted)";
      labelDiv.style.textAlign = "center";
      labelDiv.style.wordWrap = "break-word";
      labelDiv.style.overflowWrap = "break-word";
      labelDiv.style.lineHeight = "1.2";
      labelDiv.style.padding = "0 2px";
      if (barCount > 10) {
        labelDiv.style.writingMode = "vertical-rl";
        labelDiv.style.textOrientation = "mixed";
        labelDiv.style.transform = "rotate(180deg)";
        labelDiv.style.alignItems = "center";
      }
      labelDiv.textContent = item.group;
      foreignObject.appendChild(labelDiv);
      svg.appendChild(foreignObject);
    });
  }
};
