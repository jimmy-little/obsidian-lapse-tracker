/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LapsePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  dateFormat: "YYYY-MM-DD HH:mm:ss",
  showSeconds: true,
  startTimeKey: "startTime",
  endTimeKey: "endTime",
  entriesKey: "lapseEntries",
  totalTimeKey: "totalTimeTracked",
  projectKey: "project",
  defaultLabelType: "freeText",
  defaultLabelText: "",
  defaultLabelFrontmatterKey: "project",
  removeTimestampFromFileName: false,
  defaultTagOnNote: "#lapse",
  defaultTagOnTimeEntries: "",
  timeAdjustMinutes: 5
};
var LapsePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.timeData = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    console.log("Loading Lapse plugin");
    this.registerMarkdownCodeBlockProcessor("lapse", this.processTimerCodeBlock.bind(this));
    this.registerView(
      "lapse-sidebar",
      (leaf) => new LapseSidebarView(leaf, this)
    );
    this.registerView(
      "lapse-reports",
      (leaf) => new LapseReportsView(leaf, this)
    );
    this.addRibbonIcon("clock", "Lapse: Show Active Timers", () => {
      this.activateView();
    });
    this.addCommand({
      id: "insert-lapse-timer",
      name: "Insert time tracker",
      editorCallback: (editor) => {
        editor.replaceSelection("```lapse\n\n```");
      }
    });
    this.addCommand({
      id: "show-lapse-sidebar",
      name: "Show active timers",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "show-lapse-reports",
      name: "Show time reports",
      callback: () => {
        this.activateReportsView();
      }
    });
    this.addSettingTab(new LapseSettingTab(this.app, this));
  }
  async loadEntriesFromFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return;
      }
      const frontmatter = match[1];
      const lines = frontmatter.split("\n");
      const entriesKey = this.settings.entriesKey;
      let inEntries = false;
      let currentEntry = null;
      const entries = [];
      for (let i = 0; i < lines.length; i++) {
        const originalLine = lines[i];
        const trimmed = originalLine.trim();
        const indent = originalLine.length - originalLine.trimStart().length;
        if (trimmed.startsWith(`${entriesKey}:`)) {
          inEntries = true;
          continue;
        }
        if (inEntries) {
          if (trimmed && indent === 0 && !trimmed.startsWith("-")) {
            if (currentEntry) {
              entries.push({
                id: `${filePath}-${entries.length}-${Date.now()}`,
                label: currentEntry.label || "Untitled",
                startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
                endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
                duration: (currentEntry.duration || 0) * 1e3,
                isPaused: false,
                tags: currentEntry.tags || []
              });
              currentEntry = null;
            }
            inEntries = false;
            continue;
          }
          if (trimmed.startsWith("- label:")) {
            if (currentEntry) {
              entries.push({
                id: `${filePath}-${entries.length}-${Date.now()}`,
                label: currentEntry.label || "Untitled",
                startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
                endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
                duration: (currentEntry.duration || 0) * 1e3,
                isPaused: false,
                tags: currentEntry.tags || []
              });
            }
            currentEntry = {};
            const labelMatch = trimmed.match(/^- label:\s*"?([^"]*)"?/);
            currentEntry.label = labelMatch ? labelMatch[1].trim() : "Untitled";
          } else if (trimmed.startsWith("start:") && currentEntry) {
            currentEntry.start = trimmed.replace(/start:\s*/, "").trim();
          } else if (trimmed.startsWith("end:") && currentEntry) {
            const endValue = trimmed.replace(/end:\s*/, "").trim();
            currentEntry.end = endValue || null;
          } else if (trimmed.startsWith("duration:") && currentEntry) {
            const durationStr = trimmed.replace(/duration:\s*/, "").trim();
            currentEntry.duration = parseInt(durationStr) || 0;
          } else if (trimmed.startsWith("tags:") && currentEntry) {
            const tagsStr = trimmed.replace(/tags:\s*/, "").trim();
            if (tagsStr.startsWith("[")) {
              try {
                currentEntry.tags = JSON.parse(tagsStr);
              } catch (e) {
                currentEntry.tags = [];
              }
            } else {
              currentEntry.tags = tagsStr.split(",").map((t) => t.trim()).filter((t) => t);
            }
          }
        }
      }
      if (currentEntry) {
        entries.push({
          id: `${filePath}-${entries.length}-${Date.now()}`,
          label: currentEntry.label || "Untitled",
          startTime: currentEntry.start ? new Date(currentEntry.start).getTime() : null,
          endTime: currentEntry.end ? new Date(currentEntry.end).getTime() : null,
          duration: (currentEntry.duration || 0) * 1e3,
          isPaused: false,
          tags: currentEntry.tags || []
        });
      }
      if (!this.timeData.has(filePath)) {
        this.timeData.set(filePath, {
          entries: [],
          totalTimeTracked: 0
        });
      }
      const pageData = this.timeData.get(filePath);
      pageData.entries = entries;
      pageData.totalTimeTracked = entries.reduce((sum, e) => sum + e.duration, 0);
    } catch (error) {
      console.error("Error loading entries from frontmatter:", error);
    }
  }
  getDefaultTags() {
    const defaultTag = this.settings.defaultTagOnTimeEntries.trim();
    if (defaultTag) {
      const tag = defaultTag.startsWith("#") ? defaultTag.substring(1) : defaultTag;
      return [tag];
    }
    return [];
  }
  async addDefaultTagToNote(filePath) {
    const defaultTag = this.settings.defaultTagOnNote.trim();
    if (!defaultTag) {
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      const tagName = defaultTag.startsWith("#") ? defaultTag.substring(1) : defaultTag;
      if (match) {
        const frontmatter = match[1];
        if (frontmatter.includes(`tags:`) || frontmatter.includes(`tag:`)) {
          const tagsMatch = frontmatter.match(/tags?:\s*\[?([^\]]+)\]?/);
          if (tagsMatch) {
            const existingTags = tagsMatch[1].split(",").map((t) => t.trim().replace(/['"#]/g, ""));
            if (existingTags.includes(tagName)) {
              return;
            }
          }
          const newContent = content.replace(
            /(tags?:\s*\[?)([^\]]+)(\]?)/,
            (match2, prefix, tags, suffix) => {
              const tagList = tags.split(",").map((t) => t.trim()).filter((t) => t);
              tagList.push(tagName);
              return `${prefix}${tagList.map((t) => `"${t}"`).join(", ")}${suffix}`;
            }
          );
          await this.app.vault.modify(file, newContent);
        } else {
          const newFrontmatter = frontmatter + `
tags: ["${tagName}"]`;
          const newContent = content.replace(frontmatterRegex, `---
${newFrontmatter}
---`);
          await this.app.vault.modify(file, newContent);
        }
      } else {
        const newContent = `---
tags: ["${tagName}"]
---

${content}`;
        await this.app.vault.modify(file, newContent);
      }
    } catch (error) {
      console.error("Error adding tag to note:", error);
    }
  }
  async getDefaultLabel(filePath) {
    const settings = this.settings;
    if (settings.defaultLabelType === "freeText") {
      return settings.defaultLabelText || "Untitled timer";
    } else if (settings.defaultLabelType === "frontmatter") {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian.TFile)) {
        return "Untitled timer";
      }
      try {
        const content = await this.app.vault.read(file);
        const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
        const match = content.match(frontmatterRegex);
        if (match) {
          const frontmatter = match[1];
          const key = settings.defaultLabelFrontmatterKey;
          const lines = frontmatter.split("\n");
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.startsWith(`${key}:`)) {
              let value = line.replace(new RegExp(`^${key}:\\s*`), "").trim();
              if (!value && i + 1 < lines.length) {
                const nextLine = lines[i + 1].trim();
                if (nextLine.startsWith("-")) {
                  value = nextLine.replace(/^-\s*/, "").trim();
                }
              }
              if (value) {
                value = value.replace(/^["']+|["']+$/g, "");
                value = value.replace(/\[\[|\]\]/g, "");
                value = value.replace(/^[-*•]\s*/, "");
                value = value.trim();
                if (value) {
                  return value;
                }
              }
              break;
            }
          }
        }
      } catch (error) {
        console.error("Error reading frontmatter for default label:", error);
      }
      return "Untitled timer";
    } else if (settings.defaultLabelType === "fileName") {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file && file instanceof import_obsidian.TFile) {
        let fileName = file.basename || "Untitled timer";
        if (settings.removeTimestampFromFileName) {
          fileName = this.removeTimestampFromFileName(fileName);
        }
        return fileName;
      }
      return "Untitled timer";
    }
    return "Untitled timer";
  }
  removeTimestampFromFileName(fileName) {
    let result = fileName;
    result = result.replace(/(?:^|[-_\s])(\d{8})-(\d{4,6})(?:[-_\s]|$)/g, "");
    result = result.replace(/(?:^|[-_\s])(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}(?::\d{2})?(?:\.\d{3})?)(?:Z|[-+]\d{2}:\d{2})?(?:[-_\s]|$)/gi, "");
    result = result.replace(/(?:^|[-_\s])(\d{4}-\d{2}-\d{2})[-_\s](\d{2}:\d{2}(?::\d{2})?)(?:[-_\s]|$)/g, "");
    result = result.replace(/(?:^|[-_\s])(\d{4}[-/]?\d{2}[-/]?\d{2})(?:[-_\s]|$)/g, "");
    result = result.replace(/(?:^|[-_\s])(\d{2}:\d{2}(?::\d{2})?)(?:[-_\s]|$)/g, "");
    result = result.replace(/[-_\s]{2,}/g, " ");
    result = result.replace(/^[-_\s]+|[-_\s]+$/g, "");
    result = result.trim();
    return result || fileName;
  }
  async getProjectFromFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile)) {
      return null;
    }
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const frontmatter = match[1];
      const key = this.settings.projectKey;
      const lines = frontmatter.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith(`${key}:`)) {
          let value = line.replace(new RegExp(`^${key}:\\s*`), "").trim();
          if (!value && i + 1 < lines.length) {
            const nextLine = lines[i + 1].trim();
            if (nextLine.startsWith("-")) {
              value = nextLine.replace(/^-\s*/, "").trim();
            }
          }
          if (value) {
            value = value.replace(/^["']+|["']+$/g, "");
            value = value.replace(/\[\[|\]\]/g, "");
            value = value.replace(/^[-*•]\s*/, "");
            value = value.trim();
            if (value) {
              return value;
            }
          }
          break;
        }
      }
    } catch (error) {
      console.error("Error reading frontmatter for project:", error);
    }
    return null;
  }
  async processTimerCodeBlock(source, el, ctx) {
    const filePath = ctx.sourcePath;
    await this.loadEntriesFromFrontmatter(filePath);
    if (!this.timeData.has(filePath)) {
      this.timeData.set(filePath, {
        entries: [],
        totalTimeTracked: 0
      });
    }
    const pageData = this.timeData.get(filePath);
    const activeTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
    const container = el.createDiv({ cls: "lapse-container" });
    const actionBar = container.createDiv({ cls: "lapse-action-bar" });
    const timerContainer = actionBar.createDiv({ cls: "lapse-timer-container" });
    const timerDisplay = timerContainer.createDiv({ cls: "lapse-timer-display" });
    timerDisplay.setText("--:--");
    const adjustButtonsContainer = timerContainer.createDiv({ cls: "lapse-adjust-buttons" });
    const adjustBackBtn = adjustButtonsContainer.createEl("button", { cls: "lapse-btn-adjust" });
    (0, import_obsidian.setIcon)(adjustBackBtn, "chevron-left");
    adjustBackBtn.disabled = !activeTimer;
    const adjustForwardBtn = adjustButtonsContainer.createEl("button", { cls: "lapse-btn-adjust" });
    (0, import_obsidian.setIcon)(adjustForwardBtn, "chevron-right");
    adjustForwardBtn.disabled = !activeTimer;
    const inputContainer = actionBar.createDiv({ cls: "lapse-input-container" });
    let labelDisplay;
    let labelInput = null;
    if (activeTimer) {
      labelDisplay = inputContainer.createEl("div", {
        text: activeTimer.label,
        cls: "lapse-label-display-running"
      });
    } else {
      labelInput = inputContainer.createEl("input", {
        type: "text",
        placeholder: "Timer label...",
        cls: "lapse-label-input"
      });
      labelDisplay = labelInput;
    }
    const summaryLine = inputContainer.createDiv({ cls: "lapse-summary" });
    const summaryLeft = summaryLine.createDiv({ cls: "lapse-summary-left" });
    const summaryRight = summaryLine.createDiv({ cls: "lapse-summary-right" });
    const todayLabel = summaryRight.createDiv({ cls: "lapse-today-label" });
    const buttonsContainer = actionBar.createDiv({ cls: "lapse-buttons-container" });
    const playStopBtn = buttonsContainer.createEl("button", { cls: "lapse-btn-play-stop" });
    if (activeTimer) {
      (0, import_obsidian.setIcon)(playStopBtn, "square");
    } else {
      (0, import_obsidian.setIcon)(playStopBtn, "play");
    }
    const chevronBtn = buttonsContainer.createEl("button", { cls: "lapse-btn-chevron" });
    (0, import_obsidian.setIcon)(chevronBtn, "chevron-down");
    const calculateTotalTime = () => {
      return pageData.entries.reduce((sum, e) => {
        if (e.endTime !== null) {
          return sum + e.duration;
        } else if (e.startTime !== null) {
          return sum + e.duration + (Date.now() - e.startTime);
        }
        return sum;
      }, 0);
    };
    const calculateTodayTotal = () => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const todayStart = today.getTime();
      return pageData.entries.reduce((sum, e) => {
        if (e.startTime && e.startTime >= todayStart) {
          if (e.endTime !== null) {
            return sum + e.duration;
          } else if (e.startTime !== null) {
            return sum + e.duration + (Date.now() - e.startTime);
          }
        }
        return sum;
      }, 0);
    };
    const updateDisplays = () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      adjustBackBtn.disabled = !currentActiveTimer;
      adjustForwardBtn.disabled = !currentActiveTimer;
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const elapsed = currentActiveTimer.duration + (Date.now() - currentActiveTimer.startTime);
        timerDisplay.setText(this.formatTimeAsHHMMSS(elapsed));
      } else {
        timerDisplay.setText("--:--");
      }
      const entryCount = pageData.entries.length;
      const totalTime = calculateTotalTime();
      summaryLeft.setText(`${entryCount} ${entryCount === 1 ? "entry" : "entries"}, ${this.formatTimeAsHHMMSS(totalTime)}`);
      const todayTotal = calculateTodayTotal();
      todayLabel.setText(`Today: ${this.formatTimeAsHHMMSS(todayTotal)}`);
    };
    updateDisplays();
    let updateInterval = null;
    if (activeTimer) {
      updateInterval = window.setInterval(updateDisplays, 1e3);
    }
    adjustBackBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const adjustMinutes = this.settings.timeAdjustMinutes;
        const adjustMs = adjustMinutes * 60 * 1e3;
        currentActiveTimer.startTime = currentActiveTimer.startTime - adjustMs;
        await this.updateFrontmatter(filePath);
        updateDisplays();
      }
    };
    adjustForwardBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer && currentActiveTimer.startTime) {
        const adjustMinutes = this.settings.timeAdjustMinutes;
        const adjustMs = adjustMinutes * 60 * 1e3;
        currentActiveTimer.startTime = currentActiveTimer.startTime + adjustMs;
        await this.updateFrontmatter(filePath);
        updateDisplays();
      }
    };
    const panel = container.createDiv({ cls: "lapse-panel" });
    panel.style.display = "none";
    const cardsContainer = panel.createDiv({ cls: "lapse-cards-container" });
    this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
    const addButton = panel.createEl("button", {
      text: "+ Add Entry",
      cls: "lapse-btn-add"
    });
    let isPanelOpen = false;
    chevronBtn.onclick = () => {
      isPanelOpen = !isPanelOpen;
      if (isPanelOpen) {
        panel.style.display = "block";
        (0, import_obsidian.setIcon)(chevronBtn, "chevron-up");
      } else {
        panel.style.display = "none";
        (0, import_obsidian.setIcon)(chevronBtn, "chevron-down");
      }
    };
    playStopBtn.onclick = async () => {
      const currentActiveTimer = pageData.entries.find((e) => e.startTime !== null && e.endTime === null);
      if (currentActiveTimer) {
        if (!currentActiveTimer.isPaused && currentActiveTimer.startTime) {
          currentActiveTimer.duration += Date.now() - currentActiveTimer.startTime;
        }
        currentActiveTimer.endTime = Date.now();
        currentActiveTimer.isPaused = false;
        if (updateInterval) {
          clearInterval(updateInterval);
          updateInterval = null;
        }
        await this.updateFrontmatter(filePath);
        if (labelInput) {
          labelInput.value = "";
        } else if (labelDisplay) {
          labelDisplay.remove();
          labelInput = inputContainer.createEl("input", {
            type: "text",
            placeholder: "Timer label...",
            cls: "lapse-label-input"
          });
          labelDisplay = labelInput;
        }
        (0, import_obsidian.setIcon)(playStopBtn, "play");
        updateDisplays();
        this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      } else {
        let label = "";
        if (labelInput) {
          label = labelInput.value.trim();
        }
        if (!label) {
          label = await this.getDefaultLabel(filePath);
        }
        const newEntry = {
          id: `${filePath}-${Date.now()}-${Math.random()}`,
          label,
          startTime: Date.now(),
          endTime: null,
          duration: 0,
          isPaused: false,
          tags: this.getDefaultTags()
        };
        pageData.entries.push(newEntry);
        if (!updateInterval) {
          updateInterval = window.setInterval(updateDisplays, 1e3);
        }
        await this.addDefaultTagToNote(filePath);
        await this.updateFrontmatter(filePath);
        if (labelInput) {
          labelInput.remove();
          labelDisplay = inputContainer.createEl("div", {
            text: label,
            // Use the resolved label value
            cls: "lapse-label-display-running"
          });
          labelInput = null;
        } else if (labelDisplay) {
          labelDisplay.remove();
          labelDisplay = inputContainer.createEl("div", {
            text: label,
            // Use the resolved label value
            cls: "lapse-label-display-running"
          });
        } else {
          labelDisplay = inputContainer.createEl("div", {
            text: label,
            cls: "lapse-label-display-running"
          });
        }
        (0, import_obsidian.setIcon)(playStopBtn, "square");
        updateDisplays();
        this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
        this.app.workspace.getLeavesOfType("lapse-sidebar").forEach((leaf) => {
          if (leaf.view instanceof LapseSidebarView) {
            leaf.view.refresh();
          }
        });
      }
    };
    addButton.onclick = async () => {
      const newEntry = {
        id: `${filePath}-${Date.now()}-${Math.random()}`,
        label: "New Entry",
        startTime: null,
        endTime: null,
        duration: 0,
        isPaused: false,
        tags: this.getDefaultTags()
      };
      pageData.entries.push(newEntry);
      await this.updateFrontmatter(filePath);
      this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
    };
  }
  renderEntryCards(cardsContainer, entries, filePath, labelDisplay, labelInput) {
    cardsContainer.empty();
    entries.forEach((entry) => {
      const card = cardsContainer.createDiv({ cls: "lapse-entry-card" });
      const topLine = card.createDiv({ cls: "lapse-card-top-line" });
      const labelDiv = topLine.createDiv({ cls: "lapse-card-label" });
      labelDiv.setText(entry.label);
      const actionsDiv = topLine.createDiv({ cls: "lapse-card-actions" });
      const editBtn = actionsDiv.createEl("button", { cls: "lapse-card-btn-edit" });
      const deleteBtn = actionsDiv.createEl("button", { cls: "lapse-card-btn-delete" });
      (0, import_obsidian.setIcon)(editBtn, "pencil");
      (0, import_obsidian.setIcon)(deleteBtn, "trash");
      const detailsLine = card.createDiv({ cls: "lapse-card-details" });
      const startText = entry.startTime ? new Date(entry.startTime).toLocaleString("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric",
        hour: "numeric",
        minute: "2-digit"
      }) : "--";
      const endText = entry.endTime ? new Date(entry.endTime).toLocaleString("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric",
        hour: "numeric",
        minute: "2-digit"
      }) : "--";
      detailsLine.createSpan({ text: `Start: ${startText}`, cls: "lapse-card-detail" });
      detailsLine.createSpan({ text: `End: ${endText}`, cls: "lapse-card-detail" });
      const bottomLine = card.createDiv({ cls: "lapse-card-bottom-line" });
      const durationText = this.formatTimeAsHHMMSS(entry.duration);
      bottomLine.createSpan({ text: `Duration: ${durationText}`, cls: "lapse-card-detail" });
      if (entry.tags && entry.tags.length > 0) {
        const tagsContainer = bottomLine.createDiv({ cls: "lapse-card-tags-inline" });
        entry.tags.forEach((tag) => {
          const tagEl = tagsContainer.createSpan({ text: `#${tag}`, cls: "lapse-card-tag" });
        });
      }
      editBtn.onclick = async () => {
        await this.showEditModal(entry, filePath, labelDisplay, labelInput, () => {
          const pageData = this.timeData.get(filePath);
          if (pageData) {
            this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
          }
        });
      };
      deleteBtn.onclick = async () => {
        const confirmed = await this.showDeleteConfirmation(entry.label);
        if (confirmed) {
          const pageData = this.timeData.get(filePath);
          if (pageData) {
            pageData.entries = pageData.entries.filter((e) => e.id !== entry.id);
            await this.updateFrontmatter(filePath);
            this.renderEntryCards(cardsContainer, pageData.entries, filePath, labelDisplay, labelInput);
          }
        }
      };
    });
  }
  async showEditModal(entry, filePath, labelDisplay, labelInputParam, onSave) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Edit Entry");
    const content = modal.contentEl;
    content.empty();
    const labelContainer = content.createDiv({ cls: "lapse-modal-field" });
    labelContainer.createEl("label", { text: "Label", attr: { for: "lapse-edit-label" } });
    const labelInput = labelContainer.createEl("input", {
      type: "text",
      value: entry.label,
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-label" }
    });
    const startContainer = content.createDiv({ cls: "lapse-modal-field" });
    startContainer.createEl("label", { text: "Start Time", attr: { for: "lapse-edit-start" } });
    const startInput = startContainer.createEl("input", {
      type: "datetime-local",
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-start" }
    });
    if (entry.startTime) {
      startInput.value = this.formatDateTimeLocal(new Date(entry.startTime));
    }
    const endContainer = content.createDiv({ cls: "lapse-modal-field" });
    endContainer.createEl("label", { text: "End Time", attr: { for: "lapse-edit-end" } });
    const endInput = endContainer.createEl("input", {
      type: "datetime-local",
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-end" }
    });
    if (entry.endTime) {
      endInput.value = this.formatDateTimeLocal(new Date(entry.endTime));
    }
    const durationContainer = content.createDiv({ cls: "lapse-modal-field" });
    durationContainer.createEl("label", { text: "Duration", attr: { for: "lapse-edit-duration" } });
    const durationInput = durationContainer.createEl("input", {
      type: "text",
      value: this.formatTimeAsHHMMSS(entry.duration),
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-duration", readonly: "true" }
    });
    durationInput.readOnly = true;
    const tagsContainer = content.createDiv({ cls: "lapse-modal-field" });
    tagsContainer.createEl("label", { text: "Tags (comma-separated, without #)", attr: { for: "lapse-edit-tags" } });
    const tagsInput = tagsContainer.createEl("input", {
      type: "text",
      value: (entry.tags || []).join(", "),
      cls: "lapse-modal-input",
      attr: { id: "lapse-edit-tags", placeholder: "tag1, tag2, tag3" }
    });
    const buttonContainer = content.createDiv({ cls: "lapse-modal-buttons" });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    const updateDuration = () => {
      const start = startInput.value ? new Date(startInput.value).getTime() : null;
      const end = endInput.value ? new Date(endInput.value).getTime() : null;
      if (start && end) {
        const duration = end - start;
        durationInput.value = this.formatTimeAsHHMMSS(duration);
      } else if (entry.startTime && !entry.endTime) {
        durationInput.value = this.formatTimeAsHHMMSS(entry.duration);
      } else {
        durationInput.value = this.formatTimeAsHHMMSS(entry.duration);
      }
    };
    startInput.addEventListener("change", updateDuration);
    endInput.addEventListener("change", updateDuration);
    saveBtn.onclick = async () => {
      entry.label = labelInput.value;
      if (startInput.value) {
        entry.startTime = new Date(startInput.value).getTime();
      } else {
        entry.startTime = null;
      }
      if (endInput.value) {
        entry.endTime = new Date(endInput.value).getTime();
      } else {
        entry.endTime = null;
      }
      const tagsStr = tagsInput.value.trim();
      if (tagsStr) {
        entry.tags = tagsStr.split(",").map((t) => {
          t = t.trim();
          return t.startsWith("#") ? t.substring(1) : t;
        }).filter((t) => t);
      } else {
        entry.tags = [];
      }
      if (entry.startTime && entry.endTime) {
        entry.duration = entry.endTime - entry.startTime;
      } else if (entry.startTime && !entry.endTime) {
      }
      const isActiveTimer = entry.startTime !== null && entry.endTime === null;
      if (isActiveTimer && labelDisplay) {
        if (labelInputParam) {
          labelInputParam.value = entry.label;
        } else {
          labelDisplay.setText(entry.label);
        }
      }
      await this.updateFrontmatter(filePath);
      modal.close();
      if (onSave) {
        onSave();
      }
    };
    cancelBtn.onclick = () => {
      modal.close();
    };
    modal.open();
  }
  async showDeleteConfirmation(entryLabel) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("Delete Entry");
      const content = modal.contentEl;
      content.empty();
      content.createEl("p", { text: `Are you sure you want to delete "${entryLabel}"?` });
      const buttonContainer = content.createDiv({ cls: "lapse-modal-buttons" });
      const deleteBtn = buttonContainer.createEl("button", { text: "Delete", cls: "mod-warning" });
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      deleteBtn.onclick = () => {
        modal.close();
        resolve(true);
      };
      cancelBtn.onclick = () => {
        modal.close();
        resolve(false);
      };
      modal.open();
    });
  }
  formatDateTimeLocal(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }
  formatTimeAsHHMMSS(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1e3);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor(totalSeconds % 3600 / 60);
    const seconds = totalSeconds % 60;
    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }
  async updateFrontmatter(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian.TFile))
      return;
    const pageData = this.timeData.get(filePath);
    if (!pageData)
      return;
    const content = await this.app.vault.read(file);
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    const startedEntries = pageData.entries.filter((e) => e.startTime !== null);
    const startTime = startedEntries.length > 0 ? Math.min(...startedEntries.map((e) => e.startTime)) : null;
    const completedEntries = pageData.entries.filter((e) => e.endTime !== null);
    const endTime = completedEntries.length > 0 ? Math.max(...completedEntries.map((e) => e.endTime)) : null;
    const entries = pageData.entries.map((entry) => ({
      label: entry.label,
      start: entry.startTime ? new Date(entry.startTime).toISOString() : null,
      end: entry.endTime ? new Date(entry.endTime).toISOString() : null,
      duration: Math.floor(entry.duration / 1e3),
      tags: entry.tags || []
    }));
    const totalTimeTracked = pageData.entries.filter((e) => e.endTime !== null).reduce((sum, e) => sum + e.duration, 0);
    const totalTimeFormatted = this.formatTimeAsHHMMSS(totalTimeTracked);
    let newContent;
    if (match) {
      const existingFrontmatter = match[1];
      const lines = existingFrontmatter.split("\n");
      const startTimeKey = this.settings.startTimeKey;
      const endTimeKey = this.settings.endTimeKey;
      const entriesKey = this.settings.entriesKey;
      const totalTimeKey = this.settings.totalTimeKey;
      let insideEntries = false;
      const filteredLines = [];
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith(`${entriesKey}:`)) {
          insideEntries = true;
          continue;
        }
        if (insideEntries) {
          if (line.match(/^\s+/)) {
            continue;
          }
          insideEntries = false;
        }
        if (trimmed.startsWith(`${startTimeKey}:`) || trimmed.startsWith(`${endTimeKey}:`) || trimmed.startsWith(`${totalTimeKey}:`)) {
          continue;
        }
        filteredLines.push(line);
      }
      if (startTime !== null) {
        filteredLines.push(`${startTimeKey}: ${new Date(startTime).toISOString()}`);
      }
      if (endTime !== null) {
        filteredLines.push(`${endTimeKey}: ${new Date(endTime).toISOString()}`);
      }
      if (entries.length > 0) {
        filteredLines.push(`${entriesKey}:`);
        entries.forEach((entry) => {
          filteredLines.push(`  - label: "${entry.label.replace(/"/g, '\\"')}"`);
          if (entry.start) {
            filteredLines.push(`    start: ${entry.start}`);
          }
          if (entry.end) {
            filteredLines.push(`    end: ${entry.end}`);
          }
          filteredLines.push(`    duration: ${entry.duration}`);
          if (entry.tags && entry.tags.length > 0) {
            filteredLines.push(`    tags: [${entry.tags.map((t) => `"${t}"`).join(", ")}]`);
          }
        });
      } else {
        filteredLines.push(`${entriesKey}: []`);
      }
      filteredLines.push(`${totalTimeKey}: "${totalTimeFormatted}"`);
      newContent = content.replace(frontmatterRegex, `---
${filteredLines.join("\n")}
---`);
    } else {
      const startTimeKey = this.settings.startTimeKey;
      const endTimeKey = this.settings.endTimeKey;
      const entriesKey = this.settings.entriesKey;
      const totalTimeKey = this.settings.totalTimeKey;
      const frontmatterLines = [];
      if (startTime !== null) {
        frontmatterLines.push(`${startTimeKey}: ${new Date(startTime).toISOString()}`);
      }
      if (endTime !== null) {
        frontmatterLines.push(`${endTimeKey}: ${new Date(endTime).toISOString()}`);
      }
      if (entries.length > 0) {
        frontmatterLines.push(`${entriesKey}:`);
        entries.forEach((entry) => {
          frontmatterLines.push(`  - label: "${entry.label.replace(/"/g, '\\"')}"`);
          if (entry.start) {
            frontmatterLines.push(`    start: ${entry.start}`);
          }
          if (entry.end) {
            frontmatterLines.push(`    end: ${entry.end}`);
          }
          frontmatterLines.push(`    duration: ${entry.duration}`);
          if (entry.tags && entry.tags.length > 0) {
            frontmatterLines.push(`    tags: [${entry.tags.map((t) => `"${t}"`).join(", ")}]`);
          }
        });
      } else {
        frontmatterLines.push(`${entriesKey}: []`);
      }
      frontmatterLines.push(`${totalTimeKey}: "${totalTimeFormatted}"`);
      const frontmatter = `---
${frontmatterLines.join("\n")}
---

`;
      newContent = frontmatter + content;
    }
    await this.app.vault.modify(file, newContent);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType("lapse-sidebar");
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: "lapse-sidebar", active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async activateReportsView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType("lapse-reports");
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: "lapse-reports", active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async getActiveTimers() {
    const activeTimers = [];
    this.timeData.forEach((pageData, filePath) => {
      pageData.entries.forEach((entry) => {
        if (entry.startTime && !entry.endTime) {
          activeTimers.push({ filePath, entry });
        }
      });
    });
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (this.timeData.has(filePath)) {
        continue;
      }
      await this.loadEntriesFromFrontmatter(filePath);
      const pageData = this.timeData.get(filePath);
      if (pageData) {
        pageData.entries.forEach((entry) => {
          if (entry.startTime && !entry.endTime) {
            activeTimers.push({ filePath, entry });
          }
        });
      }
    }
    return activeTimers;
  }
  onunload() {
    console.log("Unloading Lapse plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var LapseSidebarView = class extends import_obsidian.ItemView {
  // Map of entry ID to time display element
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshInterval = null;
    this.timeDisplays = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  getViewType() {
    return "lapse-sidebar";
  }
  getDisplayText() {
    return "Active Timers";
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    await this.render();
  }
  async render() {
    var _a, _b;
    const container = this.containerEl.children[1];
    container.empty();
    this.timeDisplays.clear();
    container.createEl("h4", { text: "Active Timers" });
    const activeTimers = await this.plugin.getActiveTimers();
    if (activeTimers.length === 0) {
      container.createEl("p", { text: "No active timers", cls: "lapse-sidebar-empty" });
    } else {
      const list = container.createEl("ul", { cls: "lapse-sidebar-list" });
      for (const { filePath, entry } of activeTimers) {
        const item = list.createEl("li", { cls: "lapse-sidebar-item" });
        const topLine = item.createDiv({ cls: "lapse-sidebar-top-line" });
        const file = this.app.vault.getAbstractFileByPath(filePath);
        const fileName = file && file instanceof import_obsidian.TFile ? file.basename : ((_a = filePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || filePath;
        const link = topLine.createEl("a", {
          text: fileName,
          cls: "internal-link",
          href: filePath
        });
        link.onclick = (e) => {
          e.preventDefault();
          const file2 = this.app.vault.getAbstractFileByPath(filePath);
          if (file2 && file2 instanceof import_obsidian.TFile) {
            this.app.workspace.openLinkText(filePath, "", false);
          }
        };
        const elapsed = entry.duration + (entry.isPaused ? 0 : Date.now() - entry.startTime);
        const timeText = this.plugin.formatTimeAsHHMMSS(elapsed);
        const timeDisplay = topLine.createSpan({ text: timeText, cls: "lapse-sidebar-time" });
        this.timeDisplays.set(entry.id, timeDisplay);
        const project = await this.plugin.getProjectFromFrontmatter(filePath);
        const secondLine = item.createDiv({ cls: "lapse-sidebar-second-line" });
        if (project) {
          secondLine.createSpan({ text: project, cls: "lapse-sidebar-project" });
        }
        secondLine.createSpan({ text: entry.label, cls: "lapse-sidebar-label" });
      }
    }
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayStart = today.getTime();
    const todayEntries = [];
    this.plugin.timeData.forEach((pageData, filePath) => {
      pageData.entries.forEach((entry) => {
        if (entry.startTime && entry.startTime >= todayStart && entry.endTime) {
          todayEntries.push({ filePath, entry, startTime: entry.startTime });
        }
      });
    });
    const entriesByNote = /* @__PURE__ */ new Map();
    todayEntries.forEach(({ filePath, entry, startTime }) => {
      if (!entriesByNote.has(filePath)) {
        entriesByNote.set(filePath, []);
      }
      entriesByNote.get(filePath).push({ entry, startTime });
    });
    entriesByNote.forEach((entries) => {
      entries.sort((a, b) => b.startTime - a.startTime);
    });
    const noteGroups = Array.from(entriesByNote.entries()).map(([filePath, entries]) => {
      const totalTime = entries.reduce((sum, { entry }) => sum + entry.duration, 0);
      const newestStartTime = Math.max(...entries.map((e) => e.startTime));
      return { filePath, entries, totalTime, newestStartTime };
    });
    noteGroups.sort((a, b) => b.newestStartTime - a.newestStartTime);
    if (noteGroups.length > 0) {
      container.createEl("h4", { text: "Today's Entries", cls: "lapse-sidebar-section-title" });
      const todayList = container.createEl("ul", { cls: "lapse-sidebar-list" });
      for (const { filePath, entries, totalTime } of noteGroups) {
        const item = todayList.createEl("li", { cls: "lapse-sidebar-note-group" });
        const topLine = item.createDiv({ cls: "lapse-sidebar-top-line" });
        const file = this.app.vault.getAbstractFileByPath(filePath);
        const fileName = file && file instanceof import_obsidian.TFile ? file.basename : ((_b = filePath.split("/").pop()) == null ? void 0 : _b.replace(".md", "")) || filePath;
        const link = topLine.createEl("a", {
          text: fileName,
          cls: "internal-link",
          href: filePath
        });
        link.onclick = (e) => {
          e.preventDefault();
          const file2 = this.app.vault.getAbstractFileByPath(filePath);
          if (file2 && file2 instanceof import_obsidian.TFile) {
            this.app.workspace.openLinkText(filePath, "", false);
          }
        };
        const timeText = this.plugin.formatTimeAsHHMMSS(totalTime);
        topLine.createSpan({ text: timeText, cls: "lapse-sidebar-time" });
        const project = await this.plugin.getProjectFromFrontmatter(filePath);
        if (project) {
          const secondLine = item.createDiv({ cls: "lapse-sidebar-second-line" });
          secondLine.createSpan({ text: project, cls: "lapse-sidebar-project" });
        }
        const entriesList = item.createDiv({ cls: "lapse-sidebar-entries-list" });
        entries.forEach(({ entry }) => {
          const entryLine = entriesList.createDiv({ cls: "lapse-sidebar-entry-line" });
          const entryTime = this.plugin.formatTimeAsHHMMSS(entry.duration);
          entryLine.createSpan({ text: entry.label, cls: "lapse-sidebar-entry-label" });
          entryLine.createSpan({ text: entryTime, cls: "lapse-sidebar-entry-time" });
        });
      }
    }
    await this.renderPieChart(container, todayStart);
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    this.refreshInterval = window.setInterval(() => {
      this.updateTimers().catch((err) => console.error("Error updating timers:", err));
    }, 2e3);
  }
  async updateTimers() {
    const currentActiveTimers = await this.plugin.getActiveTimers();
    const displayedEntryIds = new Set(this.timeDisplays.keys());
    const activeEntryIds = new Set(currentActiveTimers.map(({ entry }) => entry.id));
    if (currentActiveTimers.length !== displayedEntryIds.size || ![...displayedEntryIds].every((id) => activeEntryIds.has(id))) {
      await this.render();
      return;
    }
    this.timeDisplays.forEach((timeDisplay, entryId) => {
      let foundEntry = null;
      let found = false;
      for (const [filePath, pageData] of this.plugin.timeData) {
        for (const entry of pageData.entries) {
          if (entry.id === entryId && entry.startTime && !entry.endTime) {
            foundEntry = entry;
            found = true;
            break;
          }
        }
        if (found)
          break;
      }
      if (foundEntry && foundEntry.startTime) {
        const elapsed = foundEntry.duration + (foundEntry.isPaused ? 0 : Date.now() - foundEntry.startTime);
        const timeText = this.plugin.formatTimeAsHHMMSS(elapsed);
        timeDisplay.setText(timeText);
      } else {
        this.timeDisplays.delete(entryId);
      }
    });
  }
  async renderPieChart(container, todayStart) {
    const projectTimes = /* @__PURE__ */ new Map();
    let totalTimeToday = 0;
    for (const [filePath, pageData] of this.plugin.timeData) {
      for (const entry of pageData.entries) {
        if (entry.startTime && entry.startTime >= todayStart) {
          let entryDuration = 0;
          if (entry.endTime !== null) {
            entryDuration = entry.duration;
          } else if (entry.startTime !== null) {
            entryDuration = entry.duration + (Date.now() - entry.startTime);
          }
          if (entryDuration > 0) {
            totalTimeToday += entryDuration;
            const project = await this.plugin.getProjectFromFrontmatter(filePath);
            const projectName = project || "No Project";
            const currentTime = projectTimes.get(projectName) || 0;
            projectTimes.set(projectName, currentTime + entryDuration);
          }
        }
      }
    }
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (this.plugin.timeData.has(filePath)) {
        continue;
      }
      await this.plugin.loadEntriesFromFrontmatter(filePath);
      const pageData = this.plugin.timeData.get(filePath);
      if (pageData) {
        for (const entry of pageData.entries) {
          if (entry.startTime && entry.startTime >= todayStart && entry.endTime) {
            if (entry.duration > 0) {
              totalTimeToday += entry.duration;
              const project = await this.plugin.getProjectFromFrontmatter(filePath);
              const projectName = project || "No Project";
              const currentTime = projectTimes.get(projectName) || 0;
              projectTimes.set(projectName, currentTime + entry.duration);
            }
          }
        }
      }
    }
    if (totalTimeToday === 0) {
      return;
    }
    const chartSection = container.createDiv({ cls: "lapse-sidebar-chart-section" });
    chartSection.createEl("h4", { text: "Today's Summary", cls: "lapse-sidebar-section-title" });
    const totalTimeDiv = chartSection.createDiv({ cls: "lapse-sidebar-total-time" });
    totalTimeDiv.setText(this.plugin.formatTimeAsHHMMSS(totalTimeToday));
    const chartContainer = chartSection.createDiv({ cls: "lapse-sidebar-chart-container" });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "lapse-sidebar-pie-chart");
    svg.setAttribute("width", "200");
    svg.setAttribute("height", "200");
    svg.setAttribute("viewBox", "0 0 200 200");
    chartContainer.appendChild(svg);
    const colors = [
      "#4A90E2",
      "#50C878",
      "#FF6B6B",
      "#FFD93D",
      "#9B59B6",
      "#E67E22",
      "#1ABC9C",
      "#E74C3C",
      "#3498DB",
      "#2ECC71",
      "#F39C12",
      "#16A085"
    ];
    const projectData = Array.from(projectTimes.entries()).map(([name, time], index) => ({
      name,
      time,
      color: colors[index % colors.length]
    })).sort((a, b) => b.time - a.time);
    let currentAngle = -Math.PI / 2;
    const centerX = 100;
    const centerY = 100;
    const radius = 80;
    projectData.forEach(({ name, time, color }) => {
      const percentage = time / totalTimeToday;
      const angle = percentage * 2 * Math.PI;
      const startAngle = currentAngle;
      const endAngle = currentAngle + angle;
      const x1 = centerX + radius * Math.cos(startAngle);
      const y1 = centerY + radius * Math.sin(startAngle);
      const x2 = centerX + radius * Math.cos(endAngle);
      const y2 = centerY + radius * Math.sin(endAngle);
      const largeArc = angle > Math.PI ? 1 : 0;
      const pathData = [
        `M ${centerX} ${centerY}`,
        `L ${x1} ${y1}`,
        `A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`,
        "Z"
      ].join(" ");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", pathData);
      path.setAttribute("fill", color);
      path.setAttribute("stroke", "var(--background-primary)");
      path.setAttribute("stroke-width", "2");
      svg.appendChild(path);
      currentAngle += angle;
    });
    const legend = chartSection.createDiv({ cls: "lapse-sidebar-chart-legend" });
    projectData.forEach(({ name, time, color }) => {
      const legendItem = legend.createDiv({ cls: "lapse-sidebar-legend-item" });
      const colorBox = legendItem.createDiv({ cls: "lapse-sidebar-legend-color" });
      colorBox.style.backgroundColor = color;
      const label = legendItem.createDiv({ cls: "lapse-sidebar-legend-label" });
      const nameSpan = label.createSpan({ text: name });
      const timeSpan = label.createSpan({
        text: this.plugin.formatTimeAsHHMMSS(time),
        cls: "lapse-sidebar-legend-time"
      });
    });
  }
  async refresh() {
    await this.render();
  }
  async onClose() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
  }
};
var LapseSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Lapse Settings" });
    new import_obsidian.Setting(containerEl).setName("Show seconds").setDesc("Display seconds in timer").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSeconds).onChange(async (value) => {
      this.plugin.settings.showSeconds = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Frontmatter Keys" });
    new import_obsidian.Setting(containerEl).setName("Start Time Key").setDesc("Frontmatter key for start time").addText((text) => text.setPlaceholder("startTime").setValue(this.plugin.settings.startTimeKey).onChange(async (value) => {
      this.plugin.settings.startTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("End Time Key").setDesc("Frontmatter key for end time").addText((text) => text.setPlaceholder("endTime").setValue(this.plugin.settings.endTimeKey).onChange(async (value) => {
      this.plugin.settings.endTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Total Time Key").setDesc("Frontmatter key for total time tracked").addText((text) => text.setPlaceholder("totalTimeTracked").setValue(this.plugin.settings.totalTimeKey).onChange(async (value) => {
      this.plugin.settings.totalTimeKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Project Key").setDesc("Frontmatter key for project name").addText((text) => text.setPlaceholder("project").setValue(this.plugin.settings.projectKey).onChange(async (value) => {
      this.plugin.settings.projectKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Default Time Entry Label" });
    new import_obsidian.Setting(containerEl).setName("Label Type").setDesc("How to determine the default label for new time entries").addDropdown((dropdown) => dropdown.addOption("freeText", "Free Text").addOption("frontmatter", "Frontmatter").addOption("fileName", "File Name").setValue(this.plugin.settings.defaultLabelType).onChange(async (value) => {
      this.plugin.settings.defaultLabelType = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.defaultLabelType === "freeText") {
      new import_obsidian.Setting(containerEl).setName("Default Label Text").setDesc("Default text to use for new time entries").addText((text) => text.setPlaceholder("Enter default label").setValue(this.plugin.settings.defaultLabelText).onChange(async (value) => {
        this.plugin.settings.defaultLabelText = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.defaultLabelType === "frontmatter") {
      new import_obsidian.Setting(containerEl).setName("Frontmatter Key").setDesc("Frontmatter key to use for default label").addText((text) => text.setPlaceholder("project").setValue(this.plugin.settings.defaultLabelFrontmatterKey).onChange(async (value) => {
        this.plugin.settings.defaultLabelFrontmatterKey = value;
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.defaultLabelType === "fileName") {
      new import_obsidian.Setting(containerEl).setName("Remove timestamp from filename").setDesc("When enabled, removes date and time stamps from filenames when setting the default label").addToggle((toggle) => toggle.setValue(this.plugin.settings.removeTimestampFromFileName).onChange(async (value) => {
        this.plugin.settings.removeTimestampFromFileName = value;
        await this.plugin.saveSettings();
      }));
    }
    containerEl.createEl("h3", { text: "Tags" });
    new import_obsidian.Setting(containerEl).setName("Default tag on note").setDesc("Tag to add to notes when time entries are created (e.g., #lapse)").addText((text) => text.setPlaceholder("#lapse").setValue(this.plugin.settings.defaultTagOnNote).onChange(async (value) => {
      this.plugin.settings.defaultTagOnNote = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default tag on time entries").setDesc("Tag to automatically add to new time entries (leave empty for none, e.g., #work)").addText((text) => text.setPlaceholder("#work").setValue(this.plugin.settings.defaultTagOnTimeEntries).onChange(async (value) => {
      this.plugin.settings.defaultTagOnTimeEntries = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Timer Controls" });
    new import_obsidian.Setting(containerEl).setName("Time Adjust Minutes").setDesc("Number of minutes to adjust start time when using << or >> buttons").addText((text) => text.setPlaceholder("5").setValue(this.plugin.settings.timeAdjustMinutes.toString()).onChange(async (value) => {
      const numValue = parseInt(value) || 5;
      this.plugin.settings.timeAdjustMinutes = numValue;
      await this.plugin.saveSettings();
    }));
  }
};
var LapseReportsView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.period = "daily";
    this.groupBy = "note";
    this.plugin = plugin;
  }
  getViewType() {
    return "lapse-reports";
  }
  getDisplayText() {
    return "Time Reports";
  }
  getIcon() {
    return "bar-chart-2";
  }
  async onOpen() {
    await this.render();
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    const header = container.createDiv({ cls: "lapse-reports-header" });
    const tabsContainer = header.createDiv({ cls: "lapse-reports-tabs" });
    const dailyTab = tabsContainer.createEl("button", { text: "Daily", cls: "lapse-reports-tab" });
    const weeklyTab = tabsContainer.createEl("button", { text: "Weekly", cls: "lapse-reports-tab" });
    const monthlyTab = tabsContainer.createEl("button", { text: "Monthly", cls: "lapse-reports-tab" });
    const updateTabs = () => {
      [dailyTab, weeklyTab, monthlyTab].forEach((tab) => tab.removeClass("is-active"));
      if (this.period === "daily")
        dailyTab.addClass("is-active");
      if (this.period === "weekly")
        weeklyTab.addClass("is-active");
      if (this.period === "monthly")
        monthlyTab.addClass("is-active");
    };
    dailyTab.onclick = async () => {
      this.period = "daily";
      updateTabs();
      await this.render();
    };
    weeklyTab.onclick = async () => {
      this.period = "weekly";
      updateTabs();
      await this.render();
    };
    monthlyTab.onclick = async () => {
      this.period = "monthly";
      updateTabs();
      await this.render();
    };
    updateTabs();
    const controlsContainer = header.createDiv({ cls: "lapse-reports-controls" });
    const groupBySetting = controlsContainer.createDiv({ cls: "lapse-reports-groupby" });
    groupBySetting.createEl("label", { text: "Group by: " });
    const groupBySelect = groupBySetting.createEl("select", { cls: "lapse-reports-select" });
    groupBySelect.createEl("option", { text: "Note", value: "note" });
    groupBySelect.createEl("option", { text: "Project", value: "project" });
    groupBySelect.createEl("option", { text: "Date", value: "date" });
    groupBySelect.value = this.groupBy;
    groupBySelect.onchange = async () => {
      this.groupBy = groupBySelect.value;
      await this.render();
    };
    const data = await this.getReportData();
    const summary = container.createDiv({ cls: "lapse-reports-summary" });
    const totalTime = data.reduce((sum, item) => sum + item.totalTime, 0);
    summary.createEl("h3", { text: `Total: ${this.plugin.formatTimeAsHHMMSS(totalTime)}` });
    const tableContainer = container.createDiv({ cls: "lapse-reports-table-container" });
    const table = tableContainer.createEl("table", { cls: "lapse-reports-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: this.getGroupByLabel() });
    headerRow.createEl("th", { text: "Time" });
    headerRow.createEl("th", { text: "Entries" });
    const tbody = table.createEl("tbody");
    const sortedData = [...data].sort((a, b) => b.totalTime - a.totalTime);
    for (const item of sortedData) {
      const row = tbody.createEl("tr");
      row.createEl("td", { text: item.group });
      row.createEl("td", { text: this.plugin.formatTimeAsHHMMSS(item.totalTime) });
      row.createEl("td", { text: item.entryCount.toString() });
    }
    if (data.length > 0) {
      const chartContainer = container.createDiv({ cls: "lapse-reports-chart-container" });
      await this.renderChart(chartContainer, data, totalTime);
    }
  }
  getGroupByLabel() {
    switch (this.groupBy) {
      case "note":
        return "Note";
      case "project":
        return "Project";
      case "date":
        return "Date";
      default:
        return "Group";
    }
  }
  async getReportData() {
    const now = new Date();
    let startDate;
    let endDate = new Date(now);
    if (this.period === "daily") {
      startDate = new Date(now);
      startDate.setHours(0, 0, 0, 0);
    } else if (this.period === "weekly") {
      startDate = new Date(now);
      const dayOfWeek = startDate.getDay();
      startDate.setDate(startDate.getDate() - dayOfWeek);
      startDate.setHours(0, 0, 0, 0);
    } else {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      startDate.setHours(0, 0, 0, 0);
    }
    const startTime = startDate.getTime();
    const endTime = endDate.getTime();
    const entries = [];
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const filePath = file.path;
      if (!this.plugin.timeData.has(filePath)) {
        await this.plugin.loadEntriesFromFrontmatter(filePath);
      }
      const pageData = this.plugin.timeData.get(filePath);
      if (pageData) {
        const project = await this.plugin.getProjectFromFrontmatter(filePath);
        for (const entry of pageData.entries) {
          if (entry.startTime && entry.startTime >= startTime && entry.startTime <= endTime) {
            if (entry.endTime || entry.startTime && !entry.endTime) {
              entries.push({ filePath, entry, project });
            }
          }
        }
      }
    }
    const grouped = /* @__PURE__ */ new Map();
    for (const { filePath, entry, project } of entries) {
      let groupKey;
      if (this.groupBy === "note") {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        groupKey = file && file instanceof import_obsidian.TFile ? file.basename : filePath;
      } else if (this.groupBy === "project") {
        groupKey = project || "No Project";
      } else {
        const date = new Date(entry.startTime);
        if (this.period === "daily") {
          groupKey = date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
        } else if (this.period === "weekly") {
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          groupKey = `Week of ${weekStart.toLocaleDateString("en-US", { month: "short", day: "numeric" })}`;
        } else {
          groupKey = date.toLocaleDateString("en-US", { month: "long", year: "numeric" });
        }
      }
      const entryDuration = entry.endTime ? entry.duration : entry.duration + (Date.now() - entry.startTime);
      if (!grouped.has(groupKey)) {
        grouped.set(groupKey, { totalTime: 0, entryCount: 0 });
      }
      const group = grouped.get(groupKey);
      group.totalTime += entryDuration;
      group.entryCount += 1;
    }
    return Array.from(grouped.entries()).map(([group, data]) => ({
      group,
      ...data
    }));
  }
  async renderChart(container, data, totalTime) {
    container.empty();
    container.createEl("h4", { text: "Time Distribution" });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "lapse-reports-chart");
    svg.setAttribute("width", "400");
    svg.setAttribute("height", "300");
    svg.setAttribute("viewBox", "0 0 400 300");
    container.appendChild(svg);
    const maxTime = Math.max(...data.map((d) => d.totalTime));
    const barWidth = 350 / data.length;
    const maxBarHeight = 250;
    const colors = [
      "#4A90E2",
      "#50C878",
      "#FF6B6B",
      "#FFD93D",
      "#9B59B6",
      "#E67E22",
      "#1ABC9C",
      "#E74C3C"
    ];
    data.forEach((item, index) => {
      const barHeight = item.totalTime / maxTime * maxBarHeight;
      const x = 25 + index * barWidth;
      const y = 275 - barHeight;
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("x", x.toString());
      rect.setAttribute("y", y.toString());
      rect.setAttribute("width", (barWidth - 2).toString());
      rect.setAttribute("height", barHeight.toString());
      rect.setAttribute("fill", colors[index % colors.length]);
      rect.setAttribute("rx", "2");
      svg.appendChild(rect);
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", (x + barWidth / 2).toString());
      text.setAttribute("y", "290");
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", "10");
      text.setAttribute("fill", "var(--text-muted)");
      text.textContent = item.group.length > 10 ? item.group.substring(0, 10) + "..." : item.group;
      svg.appendChild(text);
    });
  }
};
